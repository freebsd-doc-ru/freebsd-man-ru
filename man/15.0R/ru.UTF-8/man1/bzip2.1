.\" FRDP path ./contrib/bzip2/bzip2.1
.\" FRDP githash 51f61fc0c7ece7a30c737341e65455841bc3f04e
.\" FRDP hash256 2740ea9d655093704cc758ab537e16809640c9acfe20eb9f7791edcad0005c25
.TH bzip2 1
.SH ИМЯ
bzip2, bunzip2 \- компрессор файлов с блочной сортировкой, v1.0.8
.br
bzcat \- распаковывает файлы в стандартный вывод
.br
bzip2recover \- восстанавливает данные из поврежденных файлов bzip2

.SH СИНТАКСИС
.ll +8
.B bzip2
[
]
.ll -8
.br
.B bunzip2
[ 
]
.br
.B bzcat
[ 
]
.br
.B bzip2recover

.SH ОПИСАНИЕ
.I bzip2
сжимает файлы, используя алгоритм сжатия текста с блочной сортировкой
Барроуза-Уилера и кодирование Хаффмана.  Сжатие, как правило, значительно
лучше, чем достигаемое более традиционными компрессорами на основе
LZ77/LZ78, и приближается к эффективности семейства статистических
компрессоров PPM.

Параметры командной строки намеренно сделаны очень похожими на
параметры
.I GNU gzip,
но они не идентичны.

.I bzip2
ожидает список имён файлов, сопровождающих флаги командной строки.
Каждый файл заменяется сжатой версией себя, с добавлением суффикса
".bz2". Каждый сжатый файл имеет ту же дату изменения, права доступа
и, когда возможно, владельца, что и соответствующий оригинал, чтобы
эти свойства можно было корректно восстановить при распаковке.
Обработка имён файлов наивна в том смысле, что нет механизма для
сохранения оригинальных имён файлов, прав доступа, владельцев или дат
в файловых системах, которые не поддерживают эти концепции, или имеют
серьезные ограничения на длину имён файлов, такие как MS-DOS.

.I bzip2
и
.I bunzip2
по умолчанию не перезаписывают существующие
файлы.  Если вы хотите, чтобы это происходило, укажите флаг \-f.

Если имена файлов не указаны,
.I bzip2
сжимает данные со стандартного
ввода на стандартный вывод.  В этом случае
.I bzip2
откажется
записывать сжатые данные на терминал, так как это будет совершенно
непонятно и поэтому бессмысленно.

.I bunzip2
(или
.I bzip2 \-d)
распаковывает все
указанные файлы.  Файлы, которые не были созданы
.I bzip2,
будут обнаружены и проигнорированы, и будет выдано предупреждение.
.I bzip2
пытается угадать имя файла для распакованного файла
из имени сжатого файла следующим образом:

       filename.bz2    становится   filename
       filename.bz     становится   filename
       filename.tbz2   становится   filename.tar
       filename.tbz    становится   filename.tar
       anyothername    становится   anyothername.out

Если файл не заканчивается одним из распознаваемых окончаний,
.I .bz2,
.I .bz,
.I .tbz2
или
.I .tbz,
.I bzip2
сообщает, что не может
угадать имя оригинального файла, и использует оригинальное имя
с добавлением
.I .out.

Как и при сжатии, отсутствие имён файлов приводит к распаковке
со стандартного ввода на стандартный вывод.

.I bunzip2
корректно распакует файл, который является
объединением двух или более сжатых файлов.  Результатом будет
объединение соответствующих распакованных файлов.  Проверка
целостности (\-t)
объединённых сжатых файлов также поддерживается.

Вы также можете сжимать или распаковывать файлы в стандартный вывод,
указав флаг \-c.  Несколько файлов могут быть сжаты и
распакованы таким образом.  Полученные выходные данные последовательно
подаются на stdout.  Сжатие нескольких файлов
таким образом создаёт поток,
содержащий несколько представлений сжатых файлов.  Такой поток
может быть корректно распакован только
.I bzip2
версии 0.9.0 или
более поздней.  Более ранние версии
.I bzip2
остановятся после распаковки
первого файла в потоке.

.I bzcat
(или
.I bzip2 -dc)
распаковывает все указанные файлы в
стандартный вывод.

.I bzip2
будет читать аргументы из переменных окружения
.I BZIP2
и
.I BZIP,
в указанном порядке, и обрабатывать их
перед любыми аргументами, прочитанными из командной строки.  Это даёт
удобный способ предоставления аргументов по умолчанию.

Сжатие всегда выполняется, даже если сжатый
файл немного
больше оригинала.  Файлы размером менее примерно ста байт
имеют тенденцию увеличиваться, поскольку механизм сжатия имеет постоянные
накладные расходы в районе 50 байт.  Случайные данные (включая вывод
большинства файловых компрессоров) кодируются примерно в 8.05 бит на байт,
что даёт расширение около 0.5%.

Для самопроверки в целях вашей защиты
.I bzip2
использует 32-битные CRC, чтобы
убедиться, что распакованная версия файла идентична оригиналу.
Это защищает от повреждения сжатых данных и от необнаруженных ошибок в
.I bzip2
(надеюсь, очень маловероятных).  Шансы остаться необнаруженным
при повреждении данных ничтожны, около одного
шанса из четырёх миллиардов для каждого обработанного файла.  Однако учтите, что
проверка происходит при распаковке, поэтому она может только сообщить, что
что-то не так.  Она не может помочь вам
восстановить оригинальные несжатые
данные.  Вы можете использовать
.I bzip2recover
чтобы попытаться восстановить данные из
повреждённых файлов.

Возвращаемые значения: 0 для нормального завершения, 1 для проблем окружения (файл
не найден, неверные флаги, ошибки ввода-вывода и т.д.), 2 для указания повреждённого
сжатого файла, 3 для внутренней ошибки целостности (например, ошибки), которая
привела к панике
.I bzip2.

.SH ПАРАМЕТРЫ
.TP
.B \-c --stdout
Сжимать или распаковывать в стандартный вывод.
.TP
.B \-d --decompress
Принудительная распаковка.
.I bzip2,
.I bunzip2
и
.I bzcat
фактически являются одной и той же программой, и решение о том, какие действия предпринимать,
принимается на основе используемого имени.  Этот флаг переопределяет этот
механизм и заставляет
.I bzip2
распаковывать.
.TP
.B \-z --compress
Дополнение к \-d: принудительное сжатие, независимо от
имени вызова.
.TP
.B \-t --test
Проверить целостность указанного файла (файлов), но не распаковывать их.
Фактически выполняется пробная распаковка, и результат отбрасывается.
.TP
.B \-f --force
Принудительная перезапись выходных файлов.  Обычно
.I bzip2
не перезаписывает
существующие выходные файлы.  Также заставляет
.I bzip2
разрывать жёсткие ссылки
на файлы, что иначе он не делает.

bzip2 обычно отказывается распаковывать файлы, которые не имеют
правильных магических байтов заголовка.  Однако при принуждении (-f) он будет пропускать
такие файлы без изменений.  Так ведёт себя GNU gzip.
.TP
.B \-k --keep
Сохранять (не удалять) входные файлы во время сжатия
или распаковки.
.TP
.B \-s --small
Уменьшить использование памяти для сжатия, распаковки и проверки.  Файлы
распаковываются и проверяются с использованием модифицированного алгоритма, который требует
только 2.5 байта на байт блока.  Это означает, что любой файл может быть
распакован в 2300к памяти, хотя и примерно в два раза медленнее обычного.

При сжатии \-s выбирает размер блока 200к, что ограничивает
использование памяти примерно той же цифрой, за счёт степени сжатия.
Короче говоря, если на вашей машине мало памяти (8 мегабайт или
меньше), используйте \-s для всего.  См. ниже УПРАВЛЕНИЕ ПАМЯТЬЮ.
.TP
.B \-q --quiet
Подавлять несущественные предупреждающие сообщения.  Сообщения, касающиеся
ошибок ввода-вывода и других критических событий, подавлены не будут.
.TP
.B \-v --verbose
Режим подробного вывода — показывает степень сжатия для каждого обработанного файла.
Дополнительные \-v увеличивают уровень подробностей, выдавая много
информации, которая в основном полезна для диагностических целей.
.TP
.B \-L --license -V --version
Показать версию программного обеспечения, условия лицензии.
.TP
.B \-1 (или \-\-fast) до \-9 (или \-\-best)
Установить размер блока в 100 к, 200 к ..  900 к при сжатии.  Не оказывает
влияния при распаковке.  См. ниже УПРАВЛЕНИЕ ПАМЯТЬЮ.
Псевдонимы \-\-fast и \-\-best предназначены в основном для совместимости с GNU gzip.
В частности, \-\-fast не делает операции
значительно быстрее.
А \-\-best лишь выбирает поведение по умолчанию.
.TP
.B \--
Обрабатывать все последующие аргументы как имена файлов, даже если они начинаются
с тире.  Это нужно, чтобы можно было обрабатывать файлы с именами, начинающимися
с тире, например: bzip2 \-- \-myfilename.
.TP
.B \--repetitive-fast --repetitive-best
Эти флаги избыточны в версиях 0.9.5 и выше.  Они предоставляли
некоторый грубый контроль над поведением алгоритма сортировки в
более ранних версиях, что иногда было полезно.  0.9.5 и выше имеют
улучшенный алгоритм, который делает эти флаги неактуальными.

.SH УПРАВЛЕНИЕ ПАМЯТЬЮ
.I bzip2
сжимает большие файлы блоками.  Размер блока влияет
как на достигаемую степень сжатия, так и на объём памяти, необходимый для
сжатия и распаковки.  Флаги \-1 через \-9
определяют размер блока соответственно от 100 000 байт до 900 000 байт (по умолчанию).
При распаковке размер блока, использованный для
сжатия, читается из заголовка сжатого файла, и
.I bunzip2
затем выделяет себе ровно столько памяти, сколько нужно для распаковки
файла.  Поскольку размеры блоков хранятся в сжатых файлах, следует, что
флаги \-1 до \-9 несущественны и поэтому игнорируются
при распаковке.

Требования к памяти для сжатия и распаковки,
в байтах, можно оценить как:

       Сжатие:   400k + ( 8 x размер блока )

       Распаковка: 100k + ( 4 x размер блока ), или
                      100k + ( 2.5 x размер блока )

Увеличение размера блока даёт быстро уменьшающуюся предельную отдачу.  Большая часть
сжатия происходит от первых двух или трёх сотен килобайт размера блока,
что стоит иметь в виду при использовании
.I bzip2
на небольших машинах.
Также важно понимать, что требование к памяти для распаковки
устанавливается во время сжатия выбором размера блока.

Для файлов, сжатых с размером блока по умолчанию 900к,
.I bunzip2
потребуется около 3700 кбайт для распаковки.  Чтобы поддерживать распаковку
любого файла на машине с 4 мегабайтами памяти,
.I bunzip2
имеет опцию для
распаковки, используя примерно половину этого объёма памяти, около 2300
кбайт.  Скорость распаковки также снижается вдвое, поэтому эту опцию следует использовать
только там, где это необходимо.  Соответствующий флаг -s.

В общем случае старайтесь использовать максимальный размер блока, позволяемый ограничениями памяти,
поскольку это максимизирует достигаемое сжатие.  Скорость сжатия и
распаковки практически не зависит от размера блока.

Другой важный момент касается файлов, которые помещаются в один блок
— то есть большинства файлов, с которыми вы столкнётесь при использовании большого размера блока.
Объём реально используемой памяти пропорционален размеру файла,
поскольку файл меньше блока.  Например, сжатие файла
длиной 20 000 байт с флагом -9 заставит компрессор
выделить около 7600к памяти, но использовать только 400к + 20000 * 8 = 560
кбайт из неё.  Аналогично, декомпрессор выделит 3700к, но использует
только 100к + 20000 * 4 = 180 кбайт.

Вот таблица, которая суммирует максимальное использование памяти для различных
размеров блоков.  Также записан общий сжатый размер для 14 файлов
Корпуса текстового сжатия Калгари общим объёмом 3 141 622 байта.  Этот
столбец даёт некоторое представление о том, как сжатие меняется с размером блока.
Эти цифры склонны недооценивать преимущество больших размеров блоков для
больших файлов, поскольку Корпус состоит в основном из небольших файлов.

           Сжатие   Распаковка   Распаковка   Размер
    Флаг   (память)   (память)   (память -s)   Корпуса

     -1      1200k       500k         350k      914704
     -2      2000k       900k         600k      877703
     -3      2800k      1300k         850k      860338
     -4      3600k      1700k        1100k      846899
     -5      4400k      2100k        1350k      845160
     -6      5200k      2500k        1600k      838626
     -7      6100k      2900k        1850k      834096
     -8      6800k      3300k        2100k      828642
     -9      7600k      3700k        2350k      828642

.SH ВОССТАНОВЛЕНИЕ ДАННЫХ ИЗ ПОВРЕЖДЕННЫХ ФАЙЛОВ
.I bzip2
сжимает файлы блоками, обычно длиной 900кбайт.  Каждый
блок обрабатывается независимо.  Если ошибка носителя или передачи приводит к
повреждению многоблочного файла .bz2,
может быть возможно
восстановить данные из неповреждённых блоков в файле.

Сжатое представление каждого блока ограничено 48-битным
шаблоном, что делает возможным найти границы блоков с
разумной уверенностью.  Каждый блок также несёт свой собственный 32-битный CRC, поэтому
повреждённые блоки можно отличить от неповреждённых.

.I bzip2recover
— это простая программа, цель которой — искать
блоки в файлах .bz2 и записывать каждый блок в свой собственный файл .bz2.
Затем вы можете использовать
.I bzip2
\-t
для проверки
целостности полученных файлов и распаковать те, которые
не повреждены.

.I bzip2recover
принимает один аргумент — имя повреждённого файла.
Имена выходных файлов разработаны так, чтобы использование
символов подстановки при последующей обработке — например,
.I "bzip2 -dc rec:*1.bz2"
—
производило файлы в правильном порядке.

.I bzip2recover
должен быть наиболее полезен при работе с большими файлами .bz2,
так как они будут содержать много блоков.  Очевидно,
бесполезно использовать его на повреждённых одноблочных файлах, поскольку
повреждённый блок не может быть восстановлен.  Если вы хотите минимизировать
любую потенциальную потерю данных из-за ошибок носителя или передачи,
вы можете рассмотреть сжатие с меньшим
размером блока.

.SH ЗАМЕЧАНИЯ О ПРОИЗВОДИТЕЛЬНОСТИ
Фаза сортировки при сжатии собирает вместе похожие строки в
файле.  Из-за этого файлы, содержащие очень длинные последовательности повторяющихся
символов,
сжимаются медленнее, чем обычно.  Версии 0.9.5 и выше справляются
намного лучше, чем предыдущие версии, в этом отношении.  Соотношение между
худшим и средним временем сжатия находится в районе 10:1.
Для предыдущих версий это соотношение было скорее 100:1.  Вы можете использовать опцию
\-vvvv, чтобы следить за прогрессом в мельчайших деталях, если хотите.

Скорость распаковки не подвержена этим явлениям.

.I bzip2
обычно выделяет несколько мегабайт памяти для работы
и затем довольно случайным образом обращается к ним.  Это означает,
что производительность как для сжатия, так и для распаковки, в значительной степени
определяется скоростью, с которой ваша машина может обслуживать промахи кэша.
Из-за этого небольшие изменения в коде для уменьшения частоты промахов
приводили к непропорционально большому повышению производительности.
Я полагаю,
.I bzip2
будет работать лучше всего на машинах с очень большими кэшами.

.SH ПРЕДОСТЕРЕЖЕНИЯ
Сообщения об ошибках ввода-вывода не так полезны, как могли бы быть.
.I bzip2
старается обнаруживать ошибки ввода-вывода и завершаться чисто, но детали
того, в чём проблема, иногда кажутся довольно вводящими в заблуждение.

Эта справочная страница относится к версии 1.0.8
.I bzip2.
Сжатые данные, созданные этой версией, полностью совместимы вперёд и
назад с предыдущими публичными выпусками, версиями
0.1pl2, 0.9.0, 0.9.5, 1.0.0, 1.0.1, 1.0.2 и выше, но со следующим
исключением: 0.9.0 и выше могут корректно распаковывать несколько
объединённых сжатых файлов.  0.1pl2 не может этого делать; она остановится
после распаковки только первого файла в потоке.

Версии
.I bzip2recover
до 1.0.2 использовали 32-битные целые числа для представления
битовых позиций в сжатых файлах, поэтому они не могли обрабатывать сжатые
файлы размером более 512 мегабайт.  Версии 1.0.2 и выше используют
64-битные целые на некоторых платформах, которые их поддерживают (цели, поддерживаемые GNU,
и Windows).  Чтобы установить, была ли bzip2recover собрана с таким ограничением,
запустите её без аргументов.  В любом случае
вы можете собрать себе неограниченную версию, если сможете перекомпилировать её
с MaybeUInt64, установленным в беззнаковое 64-битное целое.

.SH АВТОР
Джулиан Сьюард, jseward@acm.org.

https://sourceware.org/bzip2/

Идеи, воплощённые в
.I bzip2,
принадлежат (по крайней мере) следующим
людям: Майкл Барроуз и Дэвид Уилер (за преобразование блочной сортировки),
Дэвид Уилер (снова, за кодер Хаффмана), Питер
Фенвик (за структурированную модель кодирования в оригинальном
.I bzip,
и многие усовершенствования), и Алистер Моффат, Рэдфорд Нил и Ян Уиттен
(за арифметический кодер в оригинальном
.I bzip).
Я очень
обязан за их помощь, поддержку и советы.  См. руководство в
дистрибутиве исходного кода для указателей на источники документации.  Кристиан
фон Рокес побудил меня искать более быстрые алгоритмы сортировки, чтобы
ускорить сжатие.  Бела Лубкин побудил меня улучшить
производительность сжатия в худшем случае.
Донна Робинсон преобразовала документацию в XML.
Скрипты bz* произошли от скриптов GNU gzip.
Многие люди присылали патчи, помогали
с проблемами переносимости, предоставляли машины, давали советы и вообще
были полезны.
