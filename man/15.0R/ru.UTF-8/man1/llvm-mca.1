.\" Man page generated from reStructuredText.
.\" FRDP path ./usr.bin/clang/llvm-mca/llvm-mca.1
.\" FRDP githash a324c34037ef2e1101962fca4ad0c021253288e1
.\" FRDP hash256 70e950d2e804d48ce126b783048316940b026997c957e2e3ecdb845b6a51d286
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
..
.de UNINDENT
. RE
.nr rst2man-indent-level -1
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH ИМЯ
llvm-mca \- Анализатор машинного кода LLVM
.SH СИНТАКСИС
.sp
\fBllvm\-mca\fP [\fIопции\fP] [входной_файл]
.SH ОПИСАНИЕ
.sp
\fBllvm\-mca\fP — это инструмент анализа производительности, который использует информацию,
доступную в LLVM (например, модели планирования), для статического измерения производительности
машинного кода на конкретном процессоре.
.sp
Производительность измеряется с точки зрения пропускной способности, а также потребления ресурсов процессора.
В настоящее время инструмент работает для процессоров, для которых в LLVM имеется модель планирования.
.sp
Основная цель этого инструмента — не только предсказать производительность кода при запуске на целевой системе,
но и помочь в диагностике потенциальных проблем производительности.
.sp
Для данной последовательности ассемблерного кода \fBllvm\-mca\fP оценивает количество
инструкций за цикл (IPC), а также нагрузку на аппаратные ресурсы. Анализ и
стиль отчетности вдохновлены инструментом IACA от Intel.
.sp
Например, вы можете скомпилировать код с помощью clang, вывести ассемблерный код и передать его
непосредственно в \fBllvm\-mca\fP для анализа:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ clang foo.c \-O2 \-target x86_64\-unknown\-unknown \-S \-o \- | llvm\-mca \-mcpu=btver2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Или для синтаксиса Intel:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ clang foo.c \-O2 \-target x86_64\-unknown\-unknown \-mllvm \-x86\-asm\-syntax=intel \-S \-o \- | llvm\-mca \-mcpu=btver2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
(\fBllvm\-mca\fP определяет синтаксис Intel по наличию директивы \fI\&.intel_syntax\fP
в начале входных данных. По умолчанию синтаксис вывода соответствует синтаксису входных данных.)
.sp
Модели планирования используются не только для вычисления задержек и пропускной способности инструкций,
но и для понимания того, какие ресурсы процессора доступны и как их моделировать.
.sp
По своей природе качество анализа, проводимого \fBllvm\-mca\fP,
неизбежно зависит от качества моделей планирования в LLVM.
.sp
Если вы видите, что отчет о производительности неточен для какого-либо процессора,
пожалуйста, \fI\%сообщите об ошибке\fP
в соответствующий бэкенд.
.SH ОПЦИИ
.sp
Если \fBвходной_файл\fP равен \(dq\fB\-\fP\(dq или опущен, \fBllvm\-mca\fP читает со стандартного
ввода. В противном случае он будет читать из указанного имени файла.
.sp
Если опция \fI\%\-o\fP опущена, то \fBllvm\-mca\fP отправит свой вывод
на стандартный вывод, если ввод осуществляется со стандартного ввода. Если в \fI\%\-o\fP
указано \(dq\fB\-\fP\(dq, то вывод также будет отправлен на стандартный вывод.
.INDENT 0.0
.TP
.B \-help
Вывести краткую справку о параметрах командной строки.
.UNINDENT
.INDENT 0.0
.TP
.B \-o <имя_файла>
Использовать \fB<имя_файла>\fP в качестве имени файла для вывода. Подробнее см. выше.
.UNINDENT
.INDENT 0.0
.TP
.B \-mtriple=<тройка_цели>
Указать строку тройки цели.
.UNINDENT
.INDENT 0.0
.TP
.B \-march=<архитектура>
Указать архитектуру, для которой анализировать код. По умолчанию используется целевая архитектура хоста.
.UNINDENT
.INDENT 0.0
.TP
.B \-mcpu=<имя_процессора>
Указать процессор, для которого анализировать код. По умолчанию имя процессора
автоопределяется от хоста.
.UNINDENT
.INDENT 0.0
.TP
.B \-output\-asm\-variant=<идентификатор_варианта>
Указать вариант ассемблерного вывода для отчета, генерируемого инструментом.
Для x86 возможные значения: [0, 1]. Значение 0 (соответственно 1) для этого флага включает
формат AT&T (соответственно Intel) для ассемблерного кода, выводимого инструментом в отчете анализа.
.UNINDENT
.INDENT 0.0
.TP
.B \-print\-imm\-hex
Предпочитать шестнадцатеричный формат для числовых литералов в выводе ассемблера, распечатываемом как часть отчета.
.UNINDENT
.INDENT 0.0
.TP
.B \-dispatch=<ширина>
Указать другую ширину диспетчеризации для процессора. Ширина диспетчеризации
по умолчанию равна полю \(aqIssueWidth\(aq в модели планирования процессора. Если ширина равна нулю, то используется ширина диспетчеризации по умолчанию.
.UNINDENT
.INDENT 0.0
.TP
.B \-register\-file\-size=<размер>
Указать размер файла регистров. При указании этот флаг ограничивает количество
физических регистров, доступных для переименования регистров. Значение
ноль для этого флага означает \(dqнеограниченное количество физических регистров\(dq.
.UNINDENT
.INDENT 0.0
.TP
.B \-iterations=<количество итераций>
Указать количество итераций для выполнения. Если этот флаг установлен в 0, то
инструмент устанавливает количество итераций в значение по умолчанию (т.е. 100).
.UNINDENT
.INDENT 0.0
.TP
.B \-noalias=<логическое>
Если установлено, инструмент предполагает, что загрузки и сохранения не используют псевдонимы. Это поведение по умолчанию.
.UNINDENT
.INDENT 0.0
.TP
.B \-lqueue=<размер очереди загрузки>
Указать размер очереди загрузки в блоке загрузки/сохранения, эмулируемом инструментом.
По умолчанию инструмент предполагает неограниченное количество записей в очереди загрузки.
Значение ноль для этого флага игнорируется, и вместо него используется размер очереди загрузки по умолчанию.
.UNINDENT
.INDENT 0.0
.TP
.B \-squeue=<размер очереди сохранения>
Указать размер очереди сохранения в блоке загрузки/сохранения, эмулируемом
инструментом. По умолчанию инструмент предполагает неограниченное количество записей в очереди сохранения.
Значение ноль для этого флага игнорируется, и вместо него используется размер очереди сохранения по умолчанию.
.UNINDENT
.INDENT 0.0
.TP
.B \-timeline
Включить представление временной шкалы.
.UNINDENT
.INDENT 0.0
.TP
.B \-timeline\-max\-iterations=<итерации>
Ограничить количество итераций для вывода в представлении временной шкалы. По умолчанию
представление временной шкалы выводит информацию для до 10 итераций.
.UNINDENT
.INDENT 0.0
.TP
.B \-timeline\-max\-cycles=<циклы>
Ограничить количество циклов в представлении временной шкалы, или использовать 0 для отсутствия ограничения. По
умолчанию количество циклов установлено в 80.
.UNINDENT
.INDENT 0.0
.TP
.B \-resource\-pressure
Включить представление нагрузки на ресурсы. Включено по умолчанию.
.UNINDENT
.INDENT 0.0
.TP
.B \-register\-file\-stats
Включить статистику использования файла регистров.
.UNINDENT
.INDENT 0.0
.TP
.B \-dispatch\-stats
Включить дополнительную статистику диспетчеризации. Это представление собирает и анализирует события
диспетчеризации инструкций, а также события статической/динамической задержки диспетчеризации. Это представление
по умолчанию отключено.
.UNINDENT
.INDENT 0.0
.TP
.B \-scheduler\-stats
Включить дополнительную статистику планировщика. Это представление собирает и анализирует события
выдачи инструкций. Это представление по умолчанию отключено.
.UNINDENT
.INDENT 0.0
.TP
.B \-retire\-stats
Включить дополнительную статистику блока завершения. Это представление по умолчанию отключено.
.UNINDENT
.INDENT 0.0
.TP
.B \-instruction\-info
Включить представление информации об инструкциях. Включено по умолчанию.
.UNINDENT
.INDENT 0.0
.TP
.B \-show\-encoding
Включить вывод кодировок инструкций в представлении информации об инструкциях.
.UNINDENT
.INDENT 0.0
.TP
.B \-show\-barriers
Включить вывод флагов LoadBarrier и StoreBarrier в представлении информации об инструкциях.
.UNINDENT
.INDENT 0.0
.TP
.B \-all\-stats
Вывести всю аппаратную статистику. Это включает дополнительную статистику, связанную с
логикой диспетчеризации, аппаратными планировщиками, файлом(ами) регистров и блоком завершения.
Эта опция по умолчанию отключена.
.UNINDENT
.INDENT 0.0
.TP
.B \-all\-views
Включить все представления.
.UNINDENT
.INDENT 0.0
.TP
.B \-instruction\-tables
Выводит информацию о нагрузке на ресурсы на основе статической информации,
доступной из модели процессора. Отличается от представления нагрузки на ресурсы,
поскольку не требует симуляции кода. Вместо этого выводит теоретическое равномерное распределение нагрузки на ресурсы для каждой
инструкции в последовательности.
.UNINDENT
.INDENT 0.0
.TP
.B \-bottleneck\-analysis
Вывести информацию о узких местах, влияющих на пропускную способность. Этот анализ
может быть затратным и по умолчанию отключен. Узкие места выделяются
в сводном представлении. Анализ узких мест в настоящее время не поддерживается для
процессоров с in-order бэкендом.
.UNINDENT
.INDENT 0.0
.TP
.B \-json
Вывести запрошенные представления в формате JSON. Инструкции и
ресурсы процессора выводятся как члены специальных объектов верхнего уровня JSON.
Отдельные представления ссылаются на них по индексу. Однако не все представления
в настоящее время поддерживаются. Например, отчет анализа узких мест
не выводится в JSON. Все представления по умолчанию в настоящее время поддерживаются.
.UNINDENT
.INDENT 0.0
.TP
.B \-disable\-cb
Принудительно использовать общие классы CustomBehaviour и InstrPostProcess вместо
целевых реализаций. Общие классы никогда не обнаруживают пользовательские конфликты и не вносят изменений в инструкции после обработки.
.UNINDENT
.INDENT 0.0
.TP
.B \-disable\-im
Принудительно использовать общий InstrumentManager вместо целевой
реализации. Общий класс создает инструменты, которые не предоставляют
дополнительной информации, и InstrumentManager никогда не переопределяет класс
планирования по умолчанию для данной инструкции.
.UNINDENT
.SH СТАТУС ВЫХОДА
.sp
\fBllvm\-mca\fP возвращает 0 при успешном выполнении. В противном случае сообщение об ошибке выводится
в стандартный поток ошибок, и инструмент возвращает 1.
.SH ИСПОЛЬЗОВАНИЕ МАРКЕРОВ ДЛЯ АНАЛИЗА ОПРЕДЕЛЕННЫХ БЛОКОВ КОДА
.sp
\fBllvm\-mca\fP позволяет использовать специальные комментарии в коде для
помечения регионов ассемблерного кода, подлежащих анализу. Комментарий, начинающийся с
подстроки \fBLLVM\-MCA\-BEGIN\fP, отмечает начало региона анализа. Комментарий,
начинающийся с подстроки \fBLLVM\-MCA\-END\fP, отмечает конец региона.
Например:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-BEGIN
  ...
# LLVM\-MCA\-END
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Если пользовательский регион не указан, то \fBllvm\-mca\fP предполагает
регион по умолчанию, который содержит каждую инструкцию во входном файле. Каждый регион
анализируется изолированно, и итоговый отчет о производительности представляет собой объединение всех
отчетов, сгенерированных для каждого региона анализа.
.sp
Регионы анализа могут иметь имена. Например:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-BEGIN Простой пример
  add %eax, %eax
# LLVM\-MCA\-END
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Код из приведенного выше примера определяет регион с именем \(dqПростой пример\(dq с одной
инструкцией в нем. Обратите внимание, что имя региона не обязательно повторять
в директиве \fBLLVM\-MCA\-END\fP. При отсутствии перекрывающихся регионов
анонимная директива \fBLLVM\-MCA\-END\fP всегда завершает текущий активный пользовательский
регион.
.sp
Пример вложенных регионов:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-BEGIN foo
  add %eax, %edx
# LLVM\-MCA\-BEGIN bar
  sub %eax, %edx
# LLVM\-MCA\-END bar
# LLVM\-MCA\-END foo
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Пример перекрывающихся регионов:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-BEGIN foo
  add %eax, %edx
# LLVM\-MCA\-BEGIN bar
  sub %eax, %edx
# LLVM\-MCA\-END foo
  add %eax, %edx
# LLVM\-MCA\-END bar
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Обратите внимание, что несколько анонимных регионов не могут перекрываться. Также перекрывающиеся регионы
не могут иметь одинаковое имя.
.sp
Нет поддержки для пометки регионов из исходного кода высокого уровня, такого как C или
C++. В качестве обходного пути можно использовать директивы встроенного ассемблера:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int foo(int a, int b) {
  __asm volatile(\(dq# LLVM\-MCA\-BEGIN foo\(dq:::\(dqmemory\(dq);
  a += 42;
  __asm volatile(\(dq# LLVM\-MCA\-END\(dq:::\(dqmemory\(dq);
  a *= b;
  return a;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Однако это может мешать оптимизациям, таким как векторизация циклов, и может
влиять на сгенерированный код. Это связано с тем, что операторы \fB__asm\fP
воспринимаются как реальный код, имеющий важные побочные эффекты, что ограничивает преобразования
кода вокруг них. Если пользователи хотят использовать встроенный ассемблер
для вывода маркеров, то рекомендуется всегда проверять, что выходной
ассемблерный код эквивалентен ассемблерному коду, сгенерированному без маркеров.
\fI\%Опции Clang для вывода отчетов об оптимизации\fP
также могут помочь в обнаружении пропущенных оптимизаций.
.SH ИНСТРУМЕНТИРОВАННЫЕ РЕГИОНЫ
.sp
Инструментированный регион описывает регион ассемблерного кода, ограниченный
специальными директивами-комментариями LLVM\-MCA.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-<ТИП_ИНСТРУМЕНТА> <данные>
  ...  ## ассемблер
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
где \fIТИП_ИНСТРУМЕНТА\fP — это тип, определенный целевой платформой, и ожидается
использование \fIданных\fP\&.
.sp
Комментарий, начинающийся с подстроки \fILLVM\-MCA\-<ТИП_ИНСТРУМЕНТА>\fP
вносит данные в область видимости для llvm\-mca, чтобы использовать их в анализе для
всех следующих инструкций.
.sp
Если позже в списке инструкций будет найден комментарий с тем же \fIТИПОМ_ИНСТРУМЕНТА\fP,
то исходный инструментированный регион будет автоматически завершен, и начнется новый инструментированный регион.
.sp
Если есть комментарии, содержащие другой \fIТИП_ИНСТРУМЕНТА\fP,
то оба набора данных остаются доступными. В отличие от региона анализа,
инструментированный регион не нуждается в комментарии для завершения региона.
.sp
Комментарии с префиксом \fILLVM\-MCA\-\fP, но не соответствующие
допустимому \fIТИПУ_ИНСТРУМЕНТА\fP для целевой платформы, вызывают ошибку, за исключением
\fIBEGIN\fP и \fIEND\fP, поскольку они соответствуют регионам анализа. Комментарии,
которые не начинаются с \fILLVM\-MCA\-\fP, игнорируются :program \fIllvm\-mca\fP\&.
.sp
Инструкция (MCInst) добавляется в инструментированный регион R только
если ее местоположение находится в диапазоне [R.RangeStart, R.RangeEnd].
.sp
На целевых платформах RISCV векторные инструкции имеют различное поведение в зависимости
от LMUL. Код может быть инструментирован комментарием следующего вида:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-RISCV\-LMUL <M1|M2|M4|M8|MF2|MF4|MF8>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Инструмент RISCV InstrumentManager переопределит класс планирования для векторных
инструкций, чтобы использовать поведение планирования его псевдоинструкции,
которая зависит от LMUL. Имеет смысл размещать комментарии инструментов RISCV
непосредственно после инструкций \fIvset{i}vl{i}\fP, хотя
их можно разместить в любом месте программы.
.sp
Пример программы без вызова \fIvset{i}vl{i}\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# LLVM\-MCA\-RISCV\-LMUL M2
vadd.vv v2, v2, v2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Пример программы с вызовом \fIvset{i}vl{i}\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vsetvli zero, a0, e8, m1, tu, mu
# LLVM\-MCA\-RISCV\-LMUL M1
vadd.vv v2, v2, v2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Пример программы с несколькими вызовами \fIvset{i}vl{i}\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vsetvli zero, a0, e8, m1, tu, mu
# LLVM\-MCA\-RISCV\-LMUL M1
vadd.vv v2, v2, v2
vsetvli zero, a0, e8, m8, tu, mu
# LLVM\-MCA\-RISCV\-LMUL M8
vadd.vv v2, v2, v2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Пример программы с вызовом \fIvsetvl\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vsetvl rd, rs1, rs2
# LLVM\-MCA\-RISCV\-LMUL M1
vadd.vv v12, v12, v12
vsetvl rd, rs1, rs2
# LLVM\-MCA\-RISCV\-LMUL M4
vadd.vv v12, v12, v12
.ft P
.fi
.UNINDENT
.UNINDENT
.SH КАК РАБОТАЕТ LLVM-MCA
.sp
\fBllvm\-mca\fP принимает ассемблерный код в качестве входных данных. Ассемблерный код разбирается
в последовательность MCInst с помощью существующих парсеров ассемблера целевой платформы LLVM.
Разобранная последовательность MCInst затем анализируется модулем \fBКонвейер\fP
для генерации отчета о производительности.
.sp
Модуль конвейера симулирует выполнение последовательности машинного кода в
цикле итераций (по умолчанию 100). В течение этого процесса конвейер собирает
ряд статистических данных, связанных с выполнением. В конце этого процесса
конвейер генерирует и выводит отчет на основе собранной статистики.
.sp
Вот пример отчета о производительности, сгенерированного инструментом для
скалярного произведения двух упакованных векторов из четырех элементов с плавающей точкой. Анализ
проводится для целевой платформы x86, процессор btver2. Следующий результат может быть получен с помощью
следующей команды с использованием примера, расположенного по адресу
\fBtest/tools/llvm\-mca/X86/BtVer2/dot\-product.s\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ llvm\-mca \-mtriple=x86_64\-unknown\-unknown \-mcpu=btver2 \-iterations=300 dot\-product.s
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Итерации:        300
Инструкции:      900
Всего циклов:      610
Всего uOps:        900

Ширина диспетчеризации:    2
uOps за цикл:    1.48
IPC:               1.48
Обратная пропускная способность блока: 2.0


Информация об инструкциях:
[1]: #uOps
[2]: Задержка
[3]: Обратная пропускная способность
[4]: Может загружать
[5]: Может сохранять
[6]: Имеет побочные эффекты (U)

[1]    [2]    [3]    [4]    [5]    [6]    Инструкции:
 1      2     1.00                        vmulps      %xmm0, %xmm1, %xmm2
 1      3     1.00                        vhaddps     %xmm2, %xmm2, %xmm3
 1      3     1.00                        vhaddps     %xmm3, %xmm3, %xmm4


Ресурсы:
[0]   \- JALU0
[1]   \- JALU1
[2]   \- JDiv
[3]   \- JFPA
[4]   \- JFPM
[5]   \- JFPU0
[6]   \- JFPU1
[7]   \- JLAGU
[8]   \- JMul
[9]   \- JSAGU
[10]  \- JSTC
[11]  \- JVALU0
[12]  \- JVALU1
[13]  \- JVIMUL


Нагрузка на ресурсы за итерацию:
[0]    [1]    [2]    [3]    [4]    [5]    [6]    [7]    [8]    [9]    [10]   [11]   [12]   [13]
 \-      \-      \-     2.00   1.00   2.00   1.00    \-      \-      \-      \-      \-      \-      \-

Нагрузка на ресурсы по инструкциям:
[0]    [1]    [2]    [3]    [4]    [5]    [6]    [7]    [8]    [9]    [10]   [11]   [12]   [13]   Инструкции:
 \-      \-      \-      \-     1.00    \-     1.00    \-      \-      \-      \-      \-      \-      \-     vmulps      %xmm0, %xmm1, %xmm2
 \-      \-      \-     1.00    \-     1.00    \-      \-      \-      \-      \-      \-      \-      \-     vhaddps     %xmm2, %xmm2, %xmm3
 \-      \-      \-     1.00    \-     1.00    \-      \-      \-      \-      \-      \-      \-      \-     vhaddps     %xmm3, %xmm3, %xmm4
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Согласно этому отчету, ядро скалярного произведения было выполнено 300 раз,
всего 900 симулированных инструкций. Общее количество симулированных микроопераций
(uOps) также равно 900.
.sp
Отчет структурирован в трех основных разделах. Первый раздел собирает
несколько показателей производительности; цель этого раздела — дать очень краткий
обзор пропускной способности. Важными показателями производительности являются
\fBIPC\fP, \fBuOps за цикл\fP и \fBОбратная пропускная способность блока\fP.
.sp
Поле \fIШирина диспетчеризации\fP — это максимальное количество микроопераций, которые диспетчеризуются
в неупорядоченный бэкенд каждый симулированный цикл. Для процессоров с
in-order бэкендом \fIШирина диспетчеризации\fP — это максимальное количество микроопераций, выдаваемых в бэкенд каждый симулированный цикл.
.sp
IPC вычисляется делением общего количества симулированных инструкций на общее
количество циклов.
.sp
Поле \fIОбратная пропускная способность блока\fP — это величина, обратная пропускной способности блока.
Пропускная способность блока — это теоретическая величина, вычисляемая как максимальное количество блоков
(т.е. итераций), которые могут быть выполнены за симулированный такт при отсутствии
зависимостей, переносимых циклом. Пропускная способность блока ограничена сверху
скоростью диспетчеризации и доступностью аппаратных ресурсов.
.sp
При отсутствии зависимостей по данным, переносимых циклом, наблюдаемый IPC стремится к
теоретическому максимуму, который можно вычислить, разделив количество инструкций
одной итерации на \fIОбратную пропускную способность блока\fP\&.
.sp
Поле \(aquOps за цикл\(aq вычисляется делением общего количества симулированных микроопераций на общее
количество циклов. Разница между Шириной диспетчеризации и этим
полем является индикатором проблемы производительности. При отсутствии зависимостей по данным, переносимых циклом,
наблюдаемое \(aquOps за цикл\(aq должно стремиться к теоретической
максимальной пропускной способности, которая может быть вычислена делением количества uOps одной итерации на \fIОбратную пропускную способность блока\fP\&.
.sp
Поле \fIuOps за цикл\fP ограничено сверху шириной диспетчеризации. Это
потому что ширина диспетчеризации ограничивает максимальный размер группы диспетчеризации. И IPC,
и \(aquOps за цикл\(aq ограничены степенью аппаратного параллелизма.
Доступность аппаратных ресурсов влияет на распределение нагрузки на ресурсы и ограничивает количество инструкций, которые могут быть выполнены параллельно в каждом
цикле. Разница между Шириной диспетчеризации и теоретическим максимальным количеством uOps за
Цикл (вычисленным делением количества uOps одной итерации на
\fIОбратную пропускную способность блока\fP) является индикатором узкого места производительности, вызванного
нехваткой аппаратных ресурсов.
В общем, чем ниже Обратная пропускная способность блока, тем лучше.
.sp
В этом примере \fBuOps за итерацию / Обратная пропускная способность блока\fP равна 1.50. Поскольку здесь
нет зависимостей, переносимых циклом, ожидается, что наблюдаемое \fIuOps за цикл\fP будет
приближаться к 1.50, когда количество итераций стремится к бесконечности. Разница между
Шириной диспетчеризации (2.00) и теоретической максимальной пропускной способностью uOp (1.50)
является индикатором узкого места производительности, вызванного нехваткой аппаратных
ресурсов, и \fIПредставление нагрузки на ресурсы\fP может помочь идентифицировать проблемное
использование ресурсов.
.sp
Второй раздел отчета — это \fIпредставление информации об инструкциях\fP\&. Оно показывает
задержку и обратную пропускную способность каждой инструкции в последовательности. Также
предоставляется дополнительная информация, связанная с количеством микроопераций и
свойствами опкода (т.е., \(aqМожет загружать\(aq, \(aqМожет сохранять\(aq и \(aqИмеет побочные эффекты\(aq).
.sp
Поле \fIОбратная пропускная способность\fP — это величина, обратная пропускной способности инструкции. Пропускная способность
вычисляется как максимальное количество инструкций одного типа, которые могут быть
выполнены за такт при отсутствии зависимостей по операндам. В этом
примере обратная пропускная способность векторного умножения с плавающей точкой составляет 1
цикл/инструкция. Это потому, что умножитель с плавающей точкой JFPM доступен
только в конвейере JFPU1.
.sp
Кодировки инструкций выводятся в представлении информации об инструкциях, когда указан флаг
\fI\-show\-encoding\fP.
.sp
Ниже приведен пример вывода \fI\-show\-encoding\fP для ядра скалярного произведения:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Информация об инструкциях:
[1]: #uOps
[2]: Задержка
[3]: Обратная пропускная способность
[4]: Может загружать
[5]: Может сохранять
[6]: Имеет побочные эффекты (U)
[7]: Размер кодировки

[1]    [2]    [3]    [4]    [5]    [6]    [7]    Кодировки:                    Инструкции:
 1      2     1.00                         4     c5 f0 59 d0                   vmulps %xmm0, %xmm1, %xmm2
 1      4     1.00                         4     c5 eb 7c da                   vhaddps        %xmm2, %xmm2, %xmm3
 1      4     1.00                         4     c5 e3 7c e3                   vhaddps        %xmm3, %xmm3, %xmm4
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Столбец \fIРазмер кодировки\fP показывает размер инструкций в байтах.
Столбец \fIКодировки\fP показывает фактические кодировки инструкций (последовательности байтов в
шестнадцатеричном виде).
.sp
Третий раздел — это \fIПредставление нагрузки на ресурсы\fP\&. Это представление сообщает
среднее количество циклов ресурса, потребляемых каждой итерацией инструкциями
для каждого блока ресурсов процессора, доступного на целевой платформе. Информация
структурирована в двух таблицах. Первая таблица сообщает количество циклов ресурса,
затраченных в среднем за итерацию. Вторая таблица соотносит циклы ресурса
с машинной инструкцией в последовательности. Например, каждая итерация
инструкции vmulps всегда выполняется на блоке ресурса [6]
(JFPU1 - конвейер операций с плавающей точкой #1), потребляя в среднем 1 цикл ресурса
за итерацию. Обратите внимание, что на AMD Jaguar векторное умножение с плавающей точкой может
выполняться только в конвейере JFPU1, в то время как горизонтальные сложения с плавающей точкой могут
выполняться только в конвейере JFPU0.
.sp
Представление нагрузки на ресурсы помогает идентифицировать узкие места, вызванные высоким
использованием определенных аппаратных ресурсов. Ситуации с нагрузкой на ресурсы, в основном
сконцентрированной на нескольких ресурсах, следует, как правило, избегать. В идеале,
нагрузка должна равномерно распределяться между несколькими ресурсами.
.SS Представление временной шкалы
.sp
Представление временной шкалы выдает подробный отчет о переходах состояния каждой инструкции
через конвейер инструкций. Это представление включается параметром
командной строки \fB\-timeline\fP\&. По мере прохождения инструкций через различные стадии конвейера их состояния отображаются в отчете.
Эти состояния представлены следующими символами:
.INDENT 0.0
.IP \(bu 2
D : Инструкция диспетчеризована.
.IP \(bu 2
e : Инструкция выполняется.
.IP \(bu 2
E : Инструкция выполнена.
.IP \(bu 2
R : Инструкция завершена.
.IP \(bu 2
= : Инструкция уже диспетчеризована, ожидает выполнения.
.IP \(bu 2
\- : Инструкция выполнена, ожидает завершения.
.UNINDENT
.sp
Ниже представлено представление временной шкалы для подмножества примера скалярного произведения, расположенного в
\fBtest/tools/llvm\-mca/X86/BtVer2/dot\-product.s\fP и обработанного
\fBllvm\-mca\fP с помощью следующей команды:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ llvm\-mca \-mtriple=x86_64\-unknown\-unknown \-mcpu=btver2 \-iterations=3 \-timeline dot\-product.s
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Временная шкала:
                    012345
Индекс     0123456789

[0,0]     DeeER.    .    .   vmulps   %xmm0, %xmm1, %xmm2
[0,1]     D==eeeER  .    .   vhaddps  %xmm2, %xmm2, %xmm3
[0,2]     .D====eeeER    .   vhaddps  %xmm3, %xmm3, %xmm4
[1,0]     .DeeE\-\-\-\-\-R    .   vmulps   %xmm0, %xmm1, %xmm2
[1,1]     . D=eeeE\-\-\-R   .   vhaddps  %xmm2, %xmm2, %xmm3
[1,2]     . D====eeeER   .   vhaddps  %xmm3, %xmm3, %xmm4
[2,0]     .  DeeE\-\-\-\-\-R  .   vmulps   %xmm0, %xmm1, %xmm2
[2,1]     .  D====eeeER  .   vhaddps  %xmm2, %xmm2, %xmm3
[2,2]     .   D======eeeER   vhaddps  %xmm3, %xmm3, %xmm4


Среднее время ожидания (на основе временной шкалы):
[0]: Выполнения
[1]: Среднее время ожидания в очереди планировщика
[2]: Среднее время ожидания в очереди планировщика в готовом состоянии
[3]: Среднее время от записи назад до стадии завершения

      [0]    [1]    [2]    [3]
0.     3     1.0    1.0    3.3       vmulps   %xmm0, %xmm1, %xmm2
1.     3     3.3    0.7    1.0       vhaddps  %xmm2, %xmm2, %xmm3
2.     3     5.7    0.0    0.0       vhaddps  %xmm3, %xmm3, %xmm4
       3     3.3    0.5    1.4       <всего>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Представление временной шкалы интересно тем, что оно показывает изменения состояния инструкций
во время выполнения. Также оно дает представление о том, как инструмент обрабатывает инструкции,
выполняемые на целевой платформе, и как может вычисляться их временная информация.
.sp
Представление временной шкалы структурировано в две таблицы. Первая таблица показывает
изменение состояния инструкций во времени (измеряется в циклах); вторая таблица
(названная \fIСреднее время ожидания\fP) предоставляет полезную статистику времени, которая должна
помочь диагностировать узкие места производительности, вызванные длинными зависимостями по данным и
неоптимальным использованием аппаратных ресурсов.
.sp
Инструкция в представлении временной шкалы идентифицируется парой индексов, где
первый индекс идентифицирует итерацию, а второй индекс — это
индекс инструкции (т.е. где она появляется в последовательности кода). Поскольку этот
пример был сгенерирован с использованием 3 итераций: \fB\-iterations=3\fP, индексы итераций
диапазона от 0 до 2 включительно.
.sp
Исключая первый и последний столбец, оставшиеся столбцы обозначают циклы.
Циклы нумеруются последовательно, начиная с 0.
.sp
Из приведенного выше примера вывода мы знаем следующее:
.INDENT 0.0
.IP \(bu 2
Инструкция [1,0] была диспетчеризована в цикле 1.
.IP \(bu 2
Инструкция [1,0] начала выполняться в цикле 2.
.IP \(bu 2
Инструкция [1,0] достигла стадии записи назад в цикле 4.
.IP \(bu 2
Инструкция [1,0] была завершена в цикле 10.
.UNINDENT
.sp
Инструкция [1,0] (т.е., vmulps из итерации #1) не должна ждать в
очереди планировщика, пока операнды станут доступны. К моменту диспетчеризации vmulps
операнды уже доступны, и конвейер JFPU1 готов
обслужить другую инструкцию. Таким образом, инструкция может быть немедленно выдана в
конвейер JFPU1. Это демонстрируется тем, что инструкция провела
всего 1 цикл в очереди планировщика.
.sp
Существует разрыв в 5 циклов между стадией записи назад и событием завершения.
Это связано с тем, что инструкции должны завершаться в программном порядке, поэтому [1,0] должна ждать,
пока сначала завершится [0,2] (т.е., она должна ждать до цикла 10).
.sp
В примере все инструкции находятся в цепочке зависимостей RAW (Read After Write).
Регистр %xmm2, записанный vmulps, немедленно используется первым
vhaddps, а регистр %xmm3, записанный первым vhaddps, используется вторым vhaddps.
Длинные зависимости по данным негативно влияют на ILP (уровень параллелизма инструкций).
.sp
В примере скалярного произведения имеются антизависимости, введенные
инструкциями из разных итераций. Однако эти зависимости могут быть
устранены на стадии переименования регистров (за счет выделения псевдонимов регистров и,
следовательно, потребления физических регистров).
.sp
Таблица \fIСреднее время ожидания\fP помогает диагностировать проблемы производительности, вызванные
наличием длительных инструкций и потенциально длинных зависимостей по данным,
которые могут ограничивать ILP. Последняя строка, \fB<всего>\fP, показывает глобальное среднее по всем
измеренным инструкциям. Обратите внимание, что \fBllvm\-mca\fP по умолчанию предполагает
по крайней мере 1 цикл между событием диспетчеризации и событием выдачи.
.sp
Когда производительность ограничена зависимостями по данным и/или длительными инструкциями,
ожидается, что количество циклов, проведенных в состоянии \fIготовности\fP, будет очень маленьким по сравнению с общим количеством циклов, проведенных в
очереди планировщика. Разница между двумя счетчиками является хорошим индикатором
того, насколько большое влияние зависимости по данным оказали на выполнение
инструкций. Когда производительность в основном ограничена нехваткой аппаратных
ресурсов, разница между двумя счетчиками мала. Однако количество
циклов, проведенных в очереди, имеет тенденцию быть больше (т.е., более 1-3 циклов),
особенно по сравнению с другими инструкциями с малой задержкой.
.SS Анализ узких мест
.sp
Параметр командной строки \fB\-bottleneck\-analysis\fP включает анализ
узких мест производительности.
.sp
Этот анализ потенциально затратен. Он пытается соотнести увеличение
нагрузки на бэкенд (вызванное нагрузкой на ресурсы конвейера и зависимостями по данным) с
задержками динамической диспетчеризации.
.sp
Ниже приведен пример вывода \fB\-bottleneck\-analysis\fP, сгенерированного
\fBllvm\-mca\fP для 500 итераций примера скалярного произведения на btver2.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Циклы с увеличением нагрузки на бэкенд [ 48.07% ]
Узкие места пропускной способности:
  Нагрузка на ресурсы       [ 47.77% ]
  \- JFPA  [ 47.77% ]
  \- JFPU0  [ 47.77% ]
  Зависимости по данным:      [ 0.30% ]
  \- Зависимости регистров [ 0.30% ]
  \- Зависимости памяти   [ 0.00% ]

Критическая последовательность на основе симуляции:

              Инструкция                         Информация о зависимостях
 +\-\-\-\-< 2.    vhaddps %xmm3, %xmm3, %xmm4
 |
 |    < переносится циклом >
 |
 |      0.    vmulps  %xmm0, %xmm1, %xmm2
 +\-\-\-\-> 1.    vhaddps %xmm2, %xmm2, %xmm3         ## ВМЕШАТЕЛЬСТВО РЕСУРСА:  JFPA [ вероятность: 74% ]
 +\-\-\-\-> 2.    vhaddps %xmm3, %xmm3, %xmm4         ## ЗАВИСИМОСТЬ РЕГИСТРА:  %xmm3
 |
 |    < переносится циклом >
 |
 +\-\-\-\-> 1.    vhaddps %xmm2, %xmm2, %xmm3         ## ВМЕШАТЕЛЬСТВО РЕСУРСА:  JFPA [ вероятность: 74% ]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Согласно анализу, пропускная способность ограничена нагрузкой на ресурсы, а не
зависимостями по данным. Анализ наблюдал увеличение нагрузки на бэкенд в течение
48.07% симулированного прогона. Почти все эти события увеличения нагрузки были
вызваны состязанием за ресурсы процессора JFPA/JFPU0.
.sp
\fIКритическая последовательность\fP — это самая дорогая последовательность инструкций согласно
симуляции. Она аннотирована, чтобы предоставить дополнительную информацию о критических
зависимостях регистров и вмешательстве ресурсов между инструкциями.
.sp
Ожидается, что инструкции из критической последовательности значительно влияют на
производительность. По построению, точность этого анализа сильно
зависит от симуляции и (как всегда) от качества модели процессора в llvm.
.sp
Анализ узких мест в настоящее время не поддерживается для процессоров с in-order
бэкендом.
.SS Дополнительная статистика для дальнейшей диагностики проблем производительности
.sp
Параметр командной строки \fB\-all\-stats\fP включает дополнительную статистику и счетчики
производительности для логики диспетчеризации, буфера переупорядочивания, блока завершения
и файла регистров.
.sp
Ниже приведен пример вывода \fB\-all\-stats\fP, сгенерированного \fBllvm\-mca\fP
для 300 итераций примера скалярного произведения, рассмотренного в предыдущих
разделах.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Циклы задержки динамической диспетчеризации:
RAT     \- Регистр недоступен:                      0
RCU     \- Токены завершения недоступны:                 0
SCHEDQ  \- Планировщик полон:                            272  (44.6%)
LQ      \- Очередь загрузки полна:                           0
SQ      \- Очередь сохранения полна:                          0
GROUP   \- Статические ограничения на группу диспетчеризации: 0


Логика диспетчеризации \- количество циклов, где мы видели N микроопераций диспетчеризовано:
[# диспетчеризовано], [# циклов]
 0,              24  (3.9%)
 1,              272  (44.6%)
 2,              314  (51.5%)


Планировщики \- количество циклов, где мы видели N микроопераций выдано:
[# выдано], [# циклов]
 0,          7  (1.1%)
 1,          306  (50.2%)
 2,          297  (48.7%)

Использование очереди планировщика:
[1] Имя ресурса.
[2] Среднее количество использованных записей буфера.
[3] Максимальное количество использованных записей буфера.
[4] Общее количество записей буфера.

 [1]            [2]        [3]        [4]
JALU01           0          0          20
JFPU01           17         18         18
JLSAGU           0          0          12


Блок завершения \- количество циклов, где мы видели N инструкций завершено:
[# завершено], [# циклов]
 0,           109  (17.9%)
 1,           102  (16.7%)
 2,           399  (65.4%)

Всего записей ROB:                64
Макс. использовано записей ROB:             35  ( 54.7% )
Среднее использованных записей ROB за цикл:  32  ( 50.0% )


Статистика файла регистров:
Всего создано отображений:    900
Макс. использовано отображений:         35

*  Файл регистров #1 \-\- JFpuPRF:
   Количество физических регистров:     72
   Всего создано отображений: 900
   Макс. использовано отображений:      35

*  Файл регистров #2 \-\- JIntegerPRF:
   Количество физических регистров:     64
   Всего создано отображений: 0
   Макс. использовано отображений:      0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Если мы посмотрим на таблицу \fIЦиклы задержки динамической диспетчеризации\fP, мы увидим, что счетчик для
SCHEDQ показывает 272 цикла. Этот счетчик увеличивается каждый раз, когда логика диспетчеризации
не может отправить полную группу, потому что очередь планировщика полна.
.sp
Глядя на таблицу \fIЛогика диспетчеризации\fP, мы видим, что конвейер смог отправить
две микрооперации только в 51.5% случаев. Группа диспетчеризации была ограничена
одной микрооперацией в 44.6% циклов, что соответствует 272 циклам.
Статистика диспетчеризации отображается либо с помощью параметра командной строки
\fB\-all\-stats\fP, либо \fB\-dispatch\-stats\fP\&.
.sp
Следующая таблица, \fIПланировщики\fP, представляет гистограмму, отображающую количество
циклов, в которых было выдано определенное количество микроопераций. В
этом случае из 610 симулированных циклов одиночные опкоды были выданы 306 раз
(50.2%), и было 7 циклов, в которых не было выдано ни одного опкода.
.sp
Таблица \fIИспользование очереди планировщика\fP показывает среднее и максимальное количество
записей буфера (т.е., записей очереди планировщика), используемых во время выполнения.
Ресурс JFPU01
достиг своего максимума (18 из 18 записей очереди). Обратите внимание, что AMD Jaguar реализует
три планировщика:
.INDENT 0.0
.IP \(bu 2
JALU01 \- планировщик для инструкций ALU.
.IP \(bu 2
JFPU01 \- планировщик для операций с плавающей точкой.
.IP \(bu 2
JLSAGU \- планировщик для генерации адресов.
.UNINDENT
.sp
Скалярное произведение — это ядро из трех инструкций с плавающей точкой (векторное
умножение, за которым следуют два горизонтальных сложения). Это объясняет, почему используется только планировщик с плавающей точкой.
.sp
Полная очередь планировщика вызвана либо цепочками зависимостей по данным, либо
неоптимальным использованием аппаратных ресурсов. Иногда нагрузку на ресурсы можно
смягчить, переписав ядро с использованием других инструкций, которые потребляют
другие ресурсы планировщика. Планировщики с маленькой очередью менее устойчивы
к узким местам, вызванным наличием длинных зависимостей по данным.
Статистика планировщика отображается с помощью параметра командной строки \fB\-all\-stats\fP или
\fB\-scheduler\-stats\fP\&.
.sp
Следующая таблица, \fIБлок завершения\fP, представляет гистограмму, отображающую количество
циклов, в которых было завершено определенное количество инструкций. В этом случае из 610 симулированных циклов две инструкции были завершены в течение
одного цикла 399 раз (65.4%), и было 109 циклов, в которых не было завершено ни одной инструкции.
Статистика завершения отображается с помощью параметра командной строки \fB\-all\-stats\fP или \fB\-retire\-stats\fP\&.
.sp
Последняя представленная таблица — \fIСтатистика файла регистров\fP\&. Каждый физический файл регистров
(PRF), используемый конвейером, представлен в этой таблице. В случае AMD
Jaguar есть два файла регистров, один для регистров с плавающей точкой (JFpuPRF)
и один для целочисленных регистров (JIntegerPRF). Таблица показывает, что из 900
обработанных инструкций было создано 900 отображений. Поскольку этот пример скалярного произведения
использовал только регистры с плавающей точкой, JFPuPRF был ответственен за
создание 900 отображений. Однако мы видим, что конвейер использовал только
максимум 35 из 72 доступных слотов регистров в любой момент времени. Мы можем заключить,
что файл регистров с плавающей точкой был единственным используемым файлом регистров в примере, и
что он никогда не был ограничен ресурсами. Статистика файла регистров
отображается с помощью параметра командной строки \fB\-all\-stats\fP или
\fB\-register\-file\-stats\fP\&.
.sp
В этом примере мы можем заключить, что IPC в основном ограничен зависимостями по
данным, а не нагрузкой на ресурсы.
.SS Поток инструкций
.sp
В этом разделе описывается поток инструкций через конвейер по умолчанию
\fBllvm\-mca\fP, а также функциональные блоки, задействованные в процессе.
.sp
Конвейер по умолчанию реализует следующую последовательность стадий, используемых для
обработки инструкций.
.INDENT 0.0
.IP \(bu 2
Диспетчеризация (Инструкция отправляется в планировщики).
.IP \(bu 2
Выдача (Инструкция выдается в конвейеры процессора).
.IP \(bu 2
Запись назад (Инструкция выполнена, и результаты записываются назад).
.IP \(bu 2
Завершение (Инструкция завершена; записи архитектурно фиксируются).
.UNINDENT
.sp
In-order конвейер реализует следующую последовательность стадий:
* InOrderIssue (Инструкция выдается в конвейеры процессора).
* Retire (Инструкция завершена; записи архитектурно фиксируются).
.sp
\fBllvm\-mca\fP предполагает, что все инструкции декодированы и размещены
в очереди до начала симуляции. Поэтому стадии выборки и
декодирования инструкций не моделируются. Узкие места производительности во фронтенде не
диагностируются. Также \fBllvm\-mca\fP не моделирует предсказание ветвлений.
.SS Диспетчеризация инструкций
.sp
На стадии диспетчеризации инструкции выбираются в программном порядке из
очереди уже декодированных инструкций и диспетчеризуются группами в
симулированные аппаратные планировщики.
.sp
Размер группы диспетчеризации зависит от доступности симулированных
аппаратных ресурсов. Ширина диспетчеризации процессора по умолчанию равна значению
поля \fBIssueWidth\fP в модели планирования LLVM.
.sp
Инструкция может быть диспетчеризована, если:
.INDENT 0.0
.IP \(bu 2
Размер группы диспетчеризации меньше ширины диспетчеризации процессора.
.IP \(bu 2
В буфере переупорядочивания достаточно записей.
.IP \(bu 2
Есть достаточно физических регистров для переименования регистров.
.IP \(bu 2
Планировщики не заполнены.
.UNINDENT
.sp
Модели планирования могут дополнительно указывать, какие файлы регистров доступны на
процессоре. \fBllvm\-mca\fP использует эту информацию для инициализации описаний
файлов регистров. Пользователи могут ограничить количество физических регистров, которые
глобально доступны для переименования регистров, используя параметр командной строки
\fB\-register\-file\-size\fP\&. Значение ноль для этой опции означает \fIнеограниченно\fP\&.
Зная, сколько регистров доступно для переименования, инструмент может предсказывать
задержки диспетчеризации, вызванные нехваткой физических регистров.
.sp
Количество записей буфера переупорядочивания, потребляемых инструкцией, зависит от
количества микроопераций, указанных для этой инструкции целевой моделью планирования.
Буфер переупорядочивания отвечает за отслеживание прогресса
инструкций, которые находятся в полете, и их завершение в программном порядке.
Количество записей в буфере переупорядочивания по умолчанию равно значению, указанному в поле
\fIMicroOpBufferSize\fP в целевой модели планирования.
.sp
Инструкции, отправленные в планировщики, потребляют записи буфера планировщика.
\fBllvm\-mca\fP запрашивает модель планирования, чтобы определить набор
буферизованных ресурсов, потребляемых инструкцией. Буферизованные ресурсы
рассматриваются как ресурсы планировщика.
.SS Выдача инструкций
.sp
Каждый планировщик процессора реализует буфер инструкций. Инструкция
должна ждать в буфере планировщика, пока входные регистры-операнды не станут
доступны. Только в этот момент инструкция становится готовой к выполнению и может быть выдана (потенциально вне порядка) на выполнение.
Задержки инструкций вычисляются \fBllvm\-mca\fP с помощью
модели планирования.
.sp
Планировщик \fBllvm\-mca\fP разработан для симуляции нескольких процессорных
планировщиков. Планировщик отвечает за отслеживание зависимостей по данным и
динамический выбор того, какие ресурсы процессора потребляются инструкциями.
Он делегирует управление блоками ресурсов и группами ресурсов
менеджеру ресурсов. Менеджер ресурсов отвечает за выбор блоков
ресурсов, которые потребляются инструкциями. Например, если инструкция
потребляет 1 цикл группы ресурсов, менеджер ресурсов выбирает один из
доступных блоков группы; по умолчанию менеджер ресурсов использует
циклический выбор, чтобы гарантировать, что использование ресурсов равномерно распределено между всеми блоками группы.
.sp
Планировщик \fBllvm\-mca\fP внутренне группирует инструкции в три набора:
.INDENT 0.0
.IP \(bu 2
WaitSet: набор инструкций, чьи операнды не готовы.
.IP \(bu 2
ReadySet: набор инструкций, готовых к выполнению.
.IP \(bu 2
IssuedSet: набор выполняемых инструкций.
.UNINDENT
.sp
В зависимости от доступности операндов инструкции, отправленные в
планировщик, либо помещаются в WaitSet, либо в ReadySet.
.sp
Каждый цикл планировщик проверяет, могут ли инструкции быть перемещены из WaitSet
в ReadySet, и могут ли инструкции из ReadySet быть выданы в
нижележащие конвейеры. Алгоритм отдает приоритет более старым инструкциям перед более молодыми.
.SS Стадия записи назад и завершения
.sp
Выданные инструкции перемещаются из ReadySet в IssuedSet. Там
инструкции ждут, пока не достигнут стадии записи назад. В этот момент они
удаляются из очереди, и блок завершения уведомляется.
.sp
Когда инструкции выполняются, блок завершения помечает инструкцию как
\(dqготовую к завершению.\(dq
.sp
Инструкции завершаются в программном порядке. Файл регистров уведомляется о
завершении, чтобы он мог освободить физические регистры, которые были выделены для
инструкции на стадии переименования регистров.
.SS Блок загрузки/сохранения и модель согласованности памяти
.sp
Для симуляции внеочередного выполнения операций памяти \fBllvm\-mca\fP
использует симулированный блок загрузки/сохранения (LSUnit) для симуляции спекулятивного
выполнения загрузок и сохранений.
.sp
Каждая загрузка (или сохранение) потребляет запись в очереди загрузки (или сохранения). Пользователи могут
указывать флаги \fB\-lqueue\fP и \fB\-squeue\fP, чтобы ограничить количество записей в
очередях загрузки и сохранения соответственно. Очереди по умолчанию неограничены.
.sp
LSUnit реализует ослабленную модель согласованности для загрузок и сохранений памяти.
Правила следующие:
.INDENT 0.0
.IP 1. 3
Более поздняя загрузка может обогнать более раннюю загрузку, только если между двумя загрузками нет
интервенционных сохранений или барьеров.
.IP 2. 3
Более поздняя загрузка может обогнать более раннее сохранение при условии, что загрузка не
использует псевдонимы с сохранением.
.IP 3. 3
Более позднее сохранение не может обогнать более раннее сохранение.
.IP 4. 3
Более позднее сохранение не может обогнать более раннюю загрузку.
.UNINDENT
.sp
По умолчанию LSUnit оптимистично предполагает, что загрузки не используют псевдонимы
(\fI\-noalias=true\fP) с операциями сохранения. При этом предположении более поздние загрузки
всегда могут обгонять более ранние сохранения. По сути, LSUnit не пытается
выполнять какой-либо анализ псевдонимов, чтобы предсказывать, когда загрузки и сохранения не используют псевдонимы друг с другом.
.sp
Обратите внимание, что в случае памяти с объединением записи правило 3 может быть ослаблено, чтобы
позволить переупорядочивание операций сохранения без псевдонимов. Несмотря на это, в
настоящее время нет возможности дополнительно ослабить модель памяти (\fB\-noalias\fP — это
единственная опция). По сути, нет возможности указать другой тип памяти
(например, обратная запись, объединение записи, сквозная запись; и т.д.) и, следовательно,
ослабить или усилить модель памяти.
.sp
Другие ограничения:
.INDENT 0.0
.IP \(bu 2
LSUnit не знает, когда может произойти пересылка из сохранения в загрузку.
.IP \(bu 2
LSUnit ничего не знает об иерархии кэша и типах памяти.
.IP \(bu 2
LSUnit не знает, как идентифицировать сериализующие операции и барьеры памяти.
.UNINDENT
.sp
LSUnit не пытается предсказать, попадает ли загрузка или сохранение в L1
кэш или нет. Он только знает, \(dqМожет ли инструкция загружать\(dq и/или \(dqМожет ли сохранять.\(dq Для
загрузок модель планирования предоставляет \(dqоптимистичную\(dq задержку от загрузки до использования (которая
обычно соответствует задержке от загрузки до использования при попадании в L1D).
.sp
\fBllvm\-mca\fP не знает (сам по себе) о сериализующих операциях или
инструкциях, подобных барьерам памяти. Раньше LSUnit консервативно использовал флаги инструкции
\(dqМожет загружать\(dq, \(dqМожет сохранять\(dq и немоделируемые побочные эффекты, чтобы
определить, следует ли рассматривать инструкцию как барьер памяти. Это было
неточно в целом и было изменено, так что теперь каждая инструкция имеет
флаги IsAStoreBarrier и IsALoadBarrier. Эти флаги специфичны для mca и
по умолчанию установлены в false для каждой инструкции. Если какая-либо инструкция должна иметь любой из этих флагов установленным, это должно быть сделано в классе InstrPostProcess целевой платформы.
Для примера посмотрите метод
\fIX86InstrPostProcess::postProcessInstruction\fP в файле
\fIllvm/lib/Target/X86/MCA/X86CustomBehaviour.cpp\fP\&.
.sp
Барьер загрузки/сохранения потребляет одну запись очереди загрузки/сохранения. Барьер загрузки/сохранения
обеспечивает упорядочивание загрузок/сохранений. Более поздняя загрузка не может обогнать барьер загрузки.
Также более позднее сохранение не может обогнать барьер сохранения. Более поздняя загрузка
должна ждать выполнения барьера памяти/загрузки. Барьер загрузки/сохранения
\(dqвыполняется\(dq, когда он становится самой старой записью в очереди загрузки/сохранения. Это
также означает, по построению, все более старые загрузки/сохранения были выполнены.
.sp
В заключение, полный набор правил согласованности загрузки/сохранения:
.INDENT 0.0
.IP 1. 3
Сохранение не может обогнать предыдущее сохранение.
.IP 2. 3
Сохранение не может обогнать предыдущую загрузку (независимо от \fB\-noalias\fP).
.IP 3. 3
Сохранение должно ждать, пока более старый барьер сохранения не будет полностью выполнен.
.IP 4. 3
Загрузка может обогнать предыдущую загрузку.
.IP 5. 3
Загрузка не может обогнать предыдущее сохранение, если не установлен \fB\-noalias\fP.
.IP 6. 3
Загрузка должна ждать, пока более старый барьер загрузки не будет полностью выполнен.
.UNINDENT
.SS In-order выдача и выполнение
.sp
In-order процессоры моделируются как одна стадия \fBInOrderIssueStage\fP\&. Она
обходит Диспетчеризацию, Планировщик и Блок загрузки/сохранения. Инструкции выдаются, как
только их регистры-операнды становятся доступными и требования к ресурсам выполнены.
Несколько инструкций могут быть выданы за один цикл в соответствии со значением
параметра \fBIssueWidth\fP в модели планирования LLVM.
.sp
После выдачи инструкция перемещается в набор \fBIssuedInst\fP до тех пор, пока не будет готова
к завершению. \fBllvm\-mca\fP гарантирует, что записи фиксируются по порядку. Однако,
инструкции разрешается фиксировать записи и завершаться вне порядка, если
свойство \fBRetireOOO\fP установлено в true для хотя бы одной из ее записей.
.SS Пользовательское поведение
.sp
Из-за того, что определенные инструкции не идеально выражаются в их
модели планирования, \fBllvm\-mca\fP не всегда может идеально их симулировать.
Однако изменение модели планирования не всегда является жизнеспособным
вариантом (возможно, потому что инструкция намеренно смоделирована неверно или поведение инструкции довольно сложное). Класс
CustomBehaviour может использоваться в таких случаях для обеспечения правильного
моделирования инструкций (часто путем настройки зависимостей по данным и обнаружения
конфликтов, о которых \fBllvm\-mca\fP не может знать).
.sp
\fBllvm\-mca\fP поставляется с одним общим и несколькими целевыми
классами CustomBehaviour. Общий класс будет использоваться, если используется флаг
\fB\-disable\-cb\fP или если целевой класс CustomBehaviour не существует для
этой целевой платформы. (Общий класс ничего не делает.) В настоящее время класс CustomBehaviour
является частью только in-order конвейера, но есть планы добавить его
в out-of-order конвейер в будущем.
.sp
Основной метод CustomBehaviour — \fIcheckCustomHazard()\fP, который использует
текущую инструкцию и список всех инструкций, все еще выполняющихся в
конвейере, чтобы определить, должна ли текущая инструкция быть диспетчеризована.
В качестве вывода метод возвращает целое число, представляющее количество циклов,
которое текущая инструкция должна ожидать (это может быть заниженной оценкой,
если точное число неизвестно, и значение 0 означает отсутствие задержки).
.sp
Если вы хотите добавить класс CustomBehaviour для целевой платформы, у которой его еще
нет, обратитесь к существующей реализации, чтобы увидеть, как его настроить. Классы
реализуются в целевом бэкенде (например,
\fI/llvm/lib/Target/AMDGPU/MCA/\fP), чтобы они могли иметь доступ к символам бэкенда.
.SS Менеджер инструментов
.sp
На некоторых архитектурах информация планирования для определенных инструкций
не содержит всей информации, необходимой для идентификации наиболее точного
класса планирования. Например, данные, которые могут влиять на планирование, могут
храниться в регистрах CSR.
.sp
Один из примеров — на RISCV, где значения в регистрах, таких как \fIvtype\fP
и \fIvl\fP, меняют поведение планирования векторных инструкций. Поскольку MCA
не отслеживает значения в регистрах, комментарии инструментов могут
использоваться для указания этих значений.
.sp
Основная функция InstrumentManager — \fIgetSchedClassID()\fP, которая имеет доступ
к MCInst и всем инструментам, активным для этого MCInst.
Эта функция может использовать инструменты для переопределения класса планирования
MCInst.
.sp
На RISCV комментарии инструментов, содержащие информацию о LMUL, используются
\fIgetSchedClassID()\fP для отображения векторной инструкции и активного
LMUL в класс планирования псевдоинструкции, которая описывает
базовую инструкцию и активный LMUL.
.SS Пользовательские представления
.sp
\fBllvm\-mca\fP поставляется с несколькими представлениями, такими как Представление временной шкалы и
Сводное представление. Эти представления общие и могут работать с большинством (если не со всеми)
целевыми платформами. Если вы хотите добавить новое представление в \fBllvm\-mca\fP и оно не
требует какой-либо функциональности бэкенда, которая еще не предоставлена через классы уровня MC
(MCSubtargetInfo, MCInstrInfo и т.д.), пожалуйста, добавьте его в
каталог \fI/tools/llvm\-mca/View/\fP\&. Однако, если ваше новое представление является целевым и
требует непредоставленных символов или функциональности бэкенда, вы можете определить его в
каталоге \fI/lib/Target/<TargetName>/MCA/\fP\&.
.sp
Чтобы включить это целевое представление, вам придется использовать класс
CustomBehaviour этой целевой платформы для переопределения методов \fICustomBehaviour::getViews()\fP\&.
Существует 3 варианта этих методов в зависимости от того, где вы хотите, чтобы ваше представление
появлялось в выводе: \fIgetStartViews()\fP, \fIgetPostInstrInfoViews()\fP и
\fIgetEndViews()\fP\&. Эти методы возвращают вектор представлений, поэтому вы захотите
вернуть вектор, содержащий все целевые представления для данной целевой платформы.
.sp
Поскольку эти целевые (и зависимые от бэкенда) представления требуют
вариантов \fICustomBehaviour::getViews()\fP, эти представления не будут включены, если
используется флаг \fI\-disable\-cb\fP\&.
.sp
Включение этих пользовательских представлений не влияет на непользовательские (общие) представления.
Продолжайте использовать обычные аргументы командной строки для включения / отключения тех
представлений.
.SH АВТОРЫ
Поддерживается командой LLVM (https://llvm.org/).
.SH ПРАВА
2003-2023, Проект LLVM
