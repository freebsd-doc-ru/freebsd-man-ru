.\"-
.\" Copyright 1986, Larry Wall
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following condition
.\" is met:
.\"  1. Redistributions of source code must retain the above copyright
.\"     notice, this condition and the following disclaimer.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" $OpenBSD: patch.1,v 1.27 2014/04/15 06:26:54 jmc Exp $
.\" FRDP path ./usr.bin/patch/patch.1
.\" FRDP githash b2c76c41be32f904179efed29c0ca04d53f3996c
.\" FRDP hash256 04d23b17541ac2b713e29ee88986fd991db80e157c5ddcfb112d7d4800a18ae6
.Dd November 3, 2019
.Dt PATCH 1
.Os
.Sh ИМЯ
.Nm patch
.Nd применить diff-файл к оригиналу
.Sh СИНТАКСИС
.Nm
.Bk -words
.Op Fl bCcEeflNnRstuv
.Op Fl B Ar backup-prefix
.Op Fl D Ar symbol
.Op Fl d Ar directory
.Op Fl F Ar max-fuzz
.Op Fl i Ar patchfile
.Op Fl o Ar out-file
.Op Fl p Ar strip-count
.Op Fl r Ar rej-name
.Op Fl V Cm t | nil | never | none
.Op Fl x Ar number
.Op Fl z Ar backup-ext
.Op Fl Fl posix
.Op Ar origfile Op Ar patchfile
.Ek
.Nm
.Pf \*(Lt Ar patchfile
.Sh ОПИСАНИЕ
.Nm
принимает файл исправлений, содержащий любую из четырёх форм списка различий, созданных программой
.Xr diff 1 ,
и применяет эти различия к исходному файлу, создавая исправленную версию.
Если
.Ar patchfile
опущен или указан как дефис, исправление будет прочитано со стандартного ввода.
.Pp
.Nm
попытается определить тип списка различий, если только это не переопределено опциями
.Fl c ,
.Fl e ,
.Fl n ,
или
.Fl u .
Контекстные различия (старого стиля, нового стиля и унифицированные) и обычные различия применяются непосредственно самой программой
.Nm ,
тогда как ed-различия просто передаются редактору
.Xr ed 1
через канал.
.Pp
Если
.Ar patchfile
содержит более одного исправления,
.Nm
попытается применить каждое из них, как если бы они были из отдельных файлов исправлений.
Это означает, среди прочего, что предполагается, что имя файла для исправления должно определяться для каждого списка различий, и что мусор перед каждым списком различий будет проверяться на наличие полезной информации, такой как имена файлов и уровень ревизии (см. раздел
.Sx Определение имени файла
ниже).
.Pp
Опции следующие:
.Bl -tag -width Ds
.It Xo
.Fl B Ar backup-prefix ,
.Fl Fl prefix Ar backup-prefix
.Xc
Заставляет следующий аргумент интерпретироваться как префикс к имени резервного файла.
Если этот аргумент указан, любой аргумент для
.Fl z
будет проигнорирован.
.It Fl b , Fl Fl backup
Сохранить резервную копию файла перед его изменением.
По умолчанию исходный файл сохраняется с резервным расширением
.Qq .orig ,
если только у файла уже нет нумерованной резервной копии, в этом случае создаётся нумерованная резервная копия.
Это эквивалентно указанию
.Qo Fl V Cm existing Qc .
Эта опция в настоящее время используется по умолчанию, если не указан
.Fl -posix .
.It Fl C , Fl Fl check , Fl Fl dry-run
Проверяет, что исправление может быть применено чисто, но ничего не изменяет.
.It Fl c , Fl Fl context
Заставляет
.Nm
интерпретировать файл исправлений как контекстное различие.
.It Xo
.Fl D Ar symbol ,
.Fl Fl ifdef Ar symbol
.Xc
Заставляет
.Nm
использовать конструкцию
.Qq #ifdef...#endif
для отметки изменений.
Следующий аргумент будет использоваться как отличающий символ.
Обратите внимание, что, в отличие от компилятора C, между
.Fl D
и аргументом должен быть пробел.
.It Xo
.Fl d Ar directory ,
.Fl Fl directory Ar directory
.Xc
Заставляет
.Nm
интерпретировать следующий аргумент как каталог и изменить рабочий каталог на него перед выполнением любых других действий.
.It Fl E , Fl Fl remove-empty-files
Заставляет
.Nm
удалять выходные файлы, которые оказались пустыми после применения исправлений.
Эта опция полезна при применении исправлений, которые создают или удаляют файлы.
.It Fl e , Fl Fl ed
Заставляет
.Nm
интерпретировать файл исправлений как скрипт
.Xr ed 1 .
.It Xo
.Fl F Ar max-fuzz ,
.Fl Fl fuzz Ar max-fuzz
.Xc
Устанавливает максимальный фактор нечёткости.
Эта опция применяется только к контекстным различиям и заставляет
.Nm
игнорировать до указанного количества строк при поиске мест для установки фрагмента.
Обратите внимание, что больший фактор нечёткости увеличивает вероятность ошибочного исправления.
Фактор нечёткости по умолчанию равен 2, и он не может быть установлен больше, чем количество строк контекста в контекстном различии, обычно 3.
.It Fl f , Fl Fl force
Заставляет
.Nm
предполагать, что пользователь точно знает, что делает, и не задавать никаких вопросов.
Предполагается следующее:
пропускать исправления, для которых не найден файл для исправления;
исправлять файлы, даже если у них неправильная версия для строки
.Qq Prereq :
в исправлении;
и считать, что исправления не обращены, даже если они выглядят таковыми.
Эта опция не подавляет комментарии; для этого используйте
.Fl s .
.It Xo
.Fl i Ar patchfile ,
.Fl Fl input Ar patchfile
.Xc
Заставляет следующий аргумент интерпретироваться как имя входного файла
(т.е., файла исправлений).
Эта опция может быть указана несколько раз.
.It Fl l , Fl Fl ignore-whitespace
Обеспечивает нестрогое сопоставление шаблонов, на случай если табуляции и пробелы были искажены во входном файле.
Любая последовательность пробельных символов в строке шаблона будет соответствовать любой последовательности во входном файле.
Обычные символы должны по-прежнему совпадать точно.
Каждая строка контекста всё равно должна соответствовать строке во входном файле.
.It Fl N , Fl Fl forward
Заставляет
.Nm
игнорировать исправления, которые, как он считает, обращены или уже применены.
См. также
.Fl R .
.It Fl n , Fl Fl normal
Заставляет
.Nm
интерпретировать файл исправлений как обычное различие.
.It Xo
.Fl o Ar out-file ,
.Fl Fl output Ar out-file
.Xc
Заставляет следующий аргумент интерпретироваться как имя выходного файла.
.It Xo
.Fl p Ar strip-count ,
.Fl Fl strip Ar strip-count
.Xc
Устанавливает количество удаляемых компонентов пути, которое контролирует, как обрабатываются имена путей, найденные в файле исправлений, на случай если вы храните файлы в другом каталоге, чем человек, отправивший исправление.
Количество удаляемых компонентов указывает, сколько слэшей должно быть удалено из начала имени пути.
(Любые промежуточные имена каталогов также удаляются.)
Например, предположим, что имя файла в файле исправлений было
.Pa /u/howard/src/blurfl/blurfl.c :
.Pp
Установка
.Fl p Ns Ar 0
даёт весь путь без изменений.
.Pp
.Fl p Ns Ar 1
даёт
.Pp
.D1 Pa u/howard/src/blurfl/blurfl.c
.Pp
без начального слэша.
.Pp
.Fl p Ns Ar 4
даёт
.Pp
.D1 Pa blurfl/blurfl.c
.Pp
Если не указывать
.Fl p
вообще, вы получите просто
.Pa blurfl.c ,
если только все каталоги в начальном пути
.Pq Pa u/howard/src/blurfl
не существуют и этот путь относителен,
в этом случае вы получите весь путь без изменений.
То, что получится в итоге, ищется либо в текущем каталоге, либо в каталоге, указанном опцией
.Fl d .
.It Fl R , Fl Fl reverse
Указывает
.Nm ,
что это исправление было создано с поменянными местами старым и новым файлами.
(Да, боюсь, такое иногда случается, такова человеческая природа.)
.Nm
попытается поменять местами каждый фрагмент перед применением.
Отклонённые фрагменты будут выведены в поменянном формате.
Опция
.Fl R
не будет работать со скриптами ed-различий, потому что информации слишком мало для восстановления обратной операции.
.Pp
Если первый фрагмент исправления не применяется,
.Nm
попытается обратить фрагмент, чтобы посмотреть, можно ли его применить таким образом.
Если можно, вас спросят, хотите ли вы установить опцию
.Fl R .
Если нельзя, исправление будет продолжено как обычно.
(Примечание: этот метод не может обнаружить обращённое исправление, если это обычное различие и если первая команда — добавление (т.е., должно было быть удаление), поскольку добавления всегда успешны из-за того, что нулевой контекст соответствует везде.
К счастью, большинство исправлений добавляют или изменяют строки, а не удаляют их, поэтому большинство обращённых обычных различий начнутся с удаления, которое не сработает, запустив эвристику.)
.It Xo
.Fl r Ar rej-name ,
.Fl Fl reject-file Ar rej-name
.Xc
Заставляет следующий аргумент интерпретироваться как имя файла отклонений.
.It Xo
.Fl s , Fl Fl quiet ,
.Fl Fl silent
.Xc
Заставляет
.Nm
работать тихо, если не произошла ошибка.
.It Fl t , Fl Fl batch
Похоже на
.Fl f ,
также подавляет вопросы, но делает некоторые другие предположения:
пропускать исправления, для которых не найден файл для исправления (так же, как
.Fl f ) ;
пропускать исправления, для которых у файла неправильная версия для строки
.Qq Prereq :
в исправлении;
и считать, что исправления обращены, если они выглядят таковыми.
.It Fl u , Fl Fl unified
Заставляет
.Nm
интерпретировать файл исправлений как унифицированное контекстное различие (unidiff).
.It Xo
.Fl V Cm t | nil | never | none ,
.Fl Fl version-control Cm t | nil | never | none
.Xc
Заставляет следующий аргумент интерпретироваться как метод создания имён резервных файлов.
Тип создаваемых резервных копий также может быть указан в переменных окружения
.Ev PATCH_VERSION_CONTROL
или
.Ev VERSION_CONTROL ,
которые переопределяются этой опцией.
Опция
.Fl B
переопределяет эту опцию, заставляя префикс всегда использоваться для создания имён резервных файлов.
Значения переменных окружения
.Ev PATCH_VERSION_CONTROL
и
.Ev VERSION_CONTROL
и аргумент опции
.Fl V
похожи на переменную GNU Emacs
.Dq version-control ;
они также распознают более описательные синонимы.
Допустимые значения (принимаются уникальные сокращения):
.Bl -tag -width Ds -offset indent
.It Cm t , numbered
Всегда создавать нумерованные резервные копии.
.It Cm nil , existing
Создавать нумерованные резервные копии для файлов, у которых они уже есть, и простые резервные копии для остальных.
.It Cm never , simple
Всегда создавать простые резервные копии.
.It Cm none
Не создавать резервные копии.
.El
.It Fl v , Fl Fl version
Заставляет
.Nm
вывести заголовок ревизии и уровень исправления.
.It Xo
.Fl x Ar number ,
.Fl Fl debug Ar number
.Xc
Устанавливает внутренние флаги отладки и представляет интерес только для разработчиков
.Nm .
.It Xo
.Fl z Ar backup-ext ,
.Fl Fl suffix Ar backup-ext
.Xc
Заставляет следующий аргумент интерпретироваться как расширение для резервной копии, используемое вместо
.Qq .orig .
.It Fl Fl posix
Включает строгое соответствие
.St -p1003.1-2008
, а именно:
.Bl -enum
.It
Резервные файлы не создаются, если не указана опция
.Fl b .
.It
Если не указано, используется имя файла, которое первое из старых, новых и индексных файлов существует.
.El
.El
.Ss Применение исправления
.Nm
попытается пропустить любой начальный мусор, применить различие, а затем пропустить любой конечный мусор.
Таким образом, вы можете передать
.Nm
статью или сообщение, содержащее список различий, и оно должно сработать.
Если всё различие имеет одинаковый отступ, это будет учтено.
.Pp
С контекстными различиями и, в меньшей степени, с обычными различиями,
.Nm
может обнаружить, когда номера строк, упомянутые в исправлении, неверны, и попытается найти правильное место для применения каждого фрагмента исправления.
В качестве первого предположения он берёт номер строки, упомянутый для фрагмента, плюс или минус любое смещение, использованное при применении предыдущего фрагмента.
Если это не правильное место,
.Nm
просмотрит вперёд и назад набор строк, соответствующих контексту, данному во фрагменте.
Сначала
.Nm
ищет место, где соответствуют все строки контекста.
Если такое место не найдено, и это контекстное различие, и максимальный фактор нечёткости установлен в 1 или более, то проводится другой просмотр, игнорируя первую и последнюю строки контекста.
Если это не удаётся, и максимальный фактор нечёткости установлен в 2 или более, игнорируются первые две и последние две строки контекста, и проводится ещё один просмотр.
.Pq Максимальный фактор нечёткости по умолчанию равен 2.
.Pp
Если
.Nm
не может найти место для установки фрагмента исправления, он поместит фрагмент в файл отклонений, который обычно имеет имя выходного файла плюс
.Qq .rej .
(Обратите внимание, что отклонённый фрагмент будет выведен в форме контекстного различия, независимо от того, было ли входное исправление контекстным или обычным различием.
Если входные данные были обычным различием, многие контексты будут просто пустыми.)
Номера строк во фрагментах в файле отклонений могут отличаться от тех, что в файле исправлений: они отражают приблизительное местоположение, которое
.Nm
считает правильным для фрагментов в новом файле, а не в старом.
.Pp
По завершении каждого фрагмента вам будет сообщено, удалось ли применить фрагмент или нет, и на какой строке (в новом файле)
.Nm
считает, что фрагмент должен быть.
Если это отличается от номера строки, указанного в различии, вам будет сообщено смещение.
Одно большое смещение МОЖЕТ указывать на то, что фрагмент был установлен в неправильном месте.
Вам также будет сообщено, если был использован фактор нечёткости для сопоставления, и в этом случае вам следует также быть немного подозрительным.
.Ss Определение имени файла
Если исходный файл не указан в командной строке,
.Nm
попытается выяснить из начального мусора, какое имя файла нужно редактировать.
При проверке предполагаемого имени файла компоненты пути удаляются, как указано опцией
.Fl p ,
и существование файла и возможность записи проверяются относительно текущего рабочего каталога (или каталога, указанного опцией
.Fl d ).
.Pp
Если различие является контекстным или унифицированным,
.Nm
может определить старые и новые имена файлов из заголовка различия.
Для контекстных различий
.Dq старый
файл указывается в строке, начинающейся с
.Qq *** ,
а
.Dq новый
файл указывается в строке, начинающейся с
.Qq --- .
Для унифицированного различия
.Dq старый
файл указывается в строке, начинающейся с
.Qq --- ,
а
.Dq новый
файл указывается в строке, начинающейся с
.Qq +++ .
Если в начальном мусоре есть строка
.Qq Index :
(независимо от типа различия),
.Nm
использует имя файла из этой строки как
.Dq индексный
файл.
.Pp
.Nm
выберет имя файла, выполнив следующие шаги, при этом используется первое совпадение:
.Bl -enum
.It
Если
.Nm
работает в строгом режиме
.St -p1003.1-2008
, используется первое из имён
.Dq старый ,
.Dq новый
и
.Dq индексный
файлов, которое существует.
В противном случае
.Nm
проверит либо имена
.Dq старый
и
.Dq новый
файлов, либо, для неконтекстного различия, имя
.Dq индексного
файла, и выберет имя файла с наименьшим количеством компонентов пути, самым коротким базовым именем и самой короткой общей длиной имени файла (в таком порядке).
.It
Если не найден подходящий файл для исправления, файл исправлений является контекстным или унифицированным различием, и старый файл имел нулевую длину, создаётся и используется новое имя файла.
.It
Если имя файла всё ещё не может быть определено,
.Nm
запросит у пользователя имя файла для использования.
.El
.Pp
Кроме того, если начальный мусор содержит строку
.Qq Prereq:\ \& ,
.Nm
возьмёт первое слово из строки требований (обычно номер версии) и проверит входной файл на наличие этого слова.
Если не найдено,
.Nm
запросит подтверждение перед продолжением.
.Pp
В результате вы должны быть в состоянии сказать, находясь в интерфейсе новостей, следующее:
.Pp
.Dl | patch -d /usr/src/local/blurfl
.Pp
и исправить файл в каталоге blurfl напрямую из статьи, содержащей исправление.
.Ss Резервные файлы
По умолчанию исправленная версия помещается вместо исходной, а исходный файл сохраняется в резервной копии с тем же именем и расширением
.Qq .orig ,
или как указано опциями
.Fl B ,
.Fl V ,
или
.Fl z .
Расширение, используемое для создания резервных файлов, также может быть указано в переменной окружения
.Ev SIMPLE_BACKUP_SUFFIX ,
которая переопределяется указанными выше опциями.
.Pp
Если резервный файл является символической или жёсткой ссылкой на исходный файл,
.Nm
создаёт новое имя резервного файла, изменяя первую строчную букву в последнем компоненте имени файла на заглавную.
Если в имени больше нет строчных букв, он удаляет первый символ из имени.
Этот процесс повторяется, пока не будет получено имя резервного файла, которое ещё не существует или не связано с исходным файлом.
.Pp
Вы также можете указать, куда должен идти вывод, с помощью опции
.Fl o ;
если этот файл уже существует, сначала создаётся его резервная копия.
.Ss Заметки для отправителей исправлений
Есть несколько вещей, которые вы должны иметь в виду, если собираетесь рассылать исправления:
.Pp
Во-первых, вы можете избавить людей от многих проблем, сохраняя файл
.Pa patchlevel.h ,
который исправляется для увеличения уровня исправления как первое различие в файле исправлений, который вы отправляете.
Если вы добавите строку
.Qq Prereq :
в исправление, это не позволит применять исправления не по порядку без предупреждения.
.Pp
Во-вторых, убедитесь, что вы правильно указали имена файлов, либо в заголовке контекстного различия, либо с помощью строки
.Qq Index : .
Если вы исправляете что-то в подкаталоге, обязательно скажите пользователю исправления указать опцию
.Fl p
при необходимости.
.Pp
В-третьих, вы можете создать файл, отправив различие, которое сравнивает нулевой файл с файлом, который вы хотите создать.
Если файл, который вы хотите создать, уже существует в целевом каталоге при применении различия, то
.Nm
определит исправление как потенциально обращённое и предложит обратить исправление.
.Pp
В-четвёртых, будьте осторожны, чтобы не отправлять обращённые исправления, так как это заставляет людей задуматься, не применили ли они уже исправление.
.Pp
В-пятых, хотя вы можете обойтись, поместив 582 списка различий в один файл, вероятно, разумнее сгруппировать связанные исправления в отдельные файлы на случай, если что-то пойдёт не так.
.Sh ОКРУЖЕНИЕ
.It Ev POSIXLY_CORRECT
При установке ведёт себя так, как если бы была указана опция
.Fl Fl posix .
.It Ev SIMPLE_BACKUP_SUFFIX
Расширение, используемое для имён резервных файлов вместо
.Qq .orig .
.It Ev TMPDIR
Каталог для временных файлов; по умолчанию
.Pa /tmp .
.It Ev PATCH_VERSION_CONTROL
Определяет, когда создаются нумерованные резервные файлы.
.It Ev VERSION_CONTROL
То же, что и
.Ev PATCH_VERSION_CONTROL .
.El
.Sh ФАЙЛЫ
.It Pa $TMPDIR/patch*
временные файлы
.Nm
.It Pa /dev/tty
используется для чтения ввода, когда
.Nm
запрашивает у пользователя
.El
.Sh СТАТУС ВЫХОДА
Утилита
.Nm
завершает работу со следующими значениями:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It 0
Успешное завершение.
.It 1
Одна или более строк были записаны в файл отклонений.
.It \*(Gt1
Произошла ошибка.
.El
.Pp
При применении набора исправлений в цикле вам следует проверять этот статус выхода, чтобы не применять последующее исправление к частично исправленному файлу.
.Sh ДИАГНОСТИКА
Слишком много, чтобы перечислять здесь, но в целом указывает на то, что
.Nm
не смог разобрать ваш файл исправлений.
.Pp
Сообщение
.Qq Hmm...
указывает, что в файле исправлений есть необработанный текст, и что
.Nm
пытается догадаться, есть ли в этом тексте исправление и, если есть, какого оно типа.
.Sh СМ. ТАКЖЕ
.Xr diff 1
.Sh СТАНДАРТЫ
Утилита
.Nm
соответствует спецификации
.St -p1003.1-2008
,
за исключением деталей, указанных выше для опции
.Fl -posix .
.Pp
Флаги
.Op Fl BCEFfstVvxz
и
.Op Fl -posix
являются расширениями этой спецификации.
.Sh АВТОРЫ
.An Larry Wall
с участием многих других разработчиков.
.Sh ПРЕДОСТЕРЕЖЕНИЯ
.Nm
не может определить, неверны ли номера строк в скрипте ed, и может обнаружить плохие номера строк в обычном различии только при нахождении команды
.Qq change
или
.Qq delete .
Контекстное различие с использованием фактора нечёткости 3 может иметь ту же проблему.
Пока не добавлен подходящий интерактивный интерфейс, вам, вероятно, следует делать контекстное различие в этих случаях, чтобы увидеть, имели ли изменения смысл.
Конечно, компиляция без ошибок — довольно хороший признак того, что исправление сработало, но не всегда.
.Pp
.Nm
обычно даёт правильные результаты, даже когда приходится много догадываться.
Однако результаты гарантированно правильны только тогда, когда исправление применяется к точно той же версии файла, из которой было создано исправление.
.Sh ИЗВЕСТНЫЕ ОШИБКИ
Мог бы быть умнее в частичных совпадениях, чрезмерно отклоняющихся смещениях и переставленном коде, но для этого потребовался бы дополнительный проход.
.Pp
Режим проверки исправления
.Pq Fl C
даст сбой, если вы попытаетесь проверить несколько исправлений подряд, которые основываются друг на друге.
Весь код
.Nm
пришлось бы переструктурировать, чтобы хранить временные файлы, чтобы он мог обработать эту ситуацию.
.Pp
Если код был продублирован (например, с помощью #ifdef OLDCODE ... #else ... #endif),
.Nm
неспособен исправить обе версии и, если вообще сработает, вероятно, исправит не ту версию и при этом сообщит об успехе.
.Pp
Если вы примените исправление, которое уже применили,
.Nm
сочтёт его обращённым исправлением и предложит отменить его.
Это можно считать особенностью.
