.\"
.\" FRDP path ./usr.bin/lex/lex.1
.\" FRDP githash b2c76c41be32f904179efed29c0ca04d53f3996c
.\" FRDP hash256 644e608bf5fbee791ff9c30c294e535bfa2600133823f35e631ef4a1f578aa90
.ИМЯ
flex, lex \- генератор быстрых лексических анализаторов
.СИНТАКСИС
.B flex
.B [\-bcdfhilnpstvwBFILTV78+? \-C[aefFmr] \-ooutput \-Pprefix \-Sskeleton]
.B [\-\-help \-\-version]
.I [filename ...]
.ОБЗОР
Данное руководство описывает
.I flex,
инструмент для генерации программ, выполняющих сопоставление с образцом в тексте.
Руководство включает как учебные, так и справочные разделы:
.nf

    Описание
        краткий обзор инструмента

    Некоторые простые примеры

    Формат входного файла

    Образцы
        расширенные регулярные выражения, используемые flex

    Как сопоставляется ввод
        правила для определения того, что было сопоставлено

    Действия
        как задать, что делать при сопоставлении образца

    Генерируемый сканер
        детали относительно сканера, который создает flex;
        как управлять источником ввода

    Стартовые условия
        введение контекста в ваши сканеры, и

    Множественные входные буферы
        как управлять несколькими источниками ввода; как
        сканировать из строк вместо файлов

    Правила конца файла
        специальные правила для сопоставления конца ввода

    Различные макросы
        сводка макросов, доступных для действий

    Значения, доступные пользователю
        сводка значений, доступных для действий

    Взаимодействие с Yacc
        соединение сканеров flex вместе с синтаксическими анализаторами yacc

    Опции
        директивы

    Соображения производительности
        как заставить ваш сканер работать максимально быстро

    Генерация сканеров на C++
        (экспериментальная) возможность генерации классов
        сканеров на C++

    Несовместимости с Lex и POSIX
        чем flex отличается от AT&T lex и стандарта
        POSIX lex

    Диагностика
        те сообщения об ошибках, создаваемые flex (или сканерами,
        которые он генерирует), чьи значения могут быть неочевидны

    Файлы
        файлы, используемые flex

    Недостатки / Ошибки
        известные проблемы с flex

    См. также
        другая документация, связанные инструменты

    Автор
        включает контактную информацию

.fi
.ОПИСАНИЕ
.I flex
это инструмент для генерации
.I сканеров:
программ, которые распознают лексические образцы в тексте.
.I flex
считывает
заданные входные файлы или стандартный ввод, если имена файлов не заданы,
для описания сканера, который нужно сгенерировать.
Описание представлено в виде пар
регулярных выражений и кода на C, называемых
.I правилами.
.I flex
генерирует в качестве выхода исходный файл на C,
.B lex.yy.c,
который определяет функцию
.B yylex().
Этот файл компилируется и связывается с
библиотекой
.B \-ll
для создания исполняемого файла.
При запуске исполняемого файла
он анализирует свой ввод на наличие вхождений
регулярных выражений.
Всякий раз, когда он находит одно, он выполняет
соответствующий код на C.
.НЕКОТОРЫЕ ПРОСТЫЕ ПРИМЕРЫ
Сначала несколько простых примеров, чтобы понять, как используется
.I flex.
Следующий
.I flex
ввод задает сканер, который всякий раз, когда встречает строку
.nf

    %%

.fi
По умолчанию любой текст, не сопоставленный
.I flex
сканером,
копируется на вывод, поэтому чистый эффект этого сканера -
копирование входного файла в выходной с каждым вхождением
В этом вводе есть только одно правило.
.I образец
.I действие.
.PP
Вот еще один простой пример:
.nf

    %{
            int num_lines = 0, num_chars = 0;
    %}

    %%
    \\n      ++num_lines; ++num_chars;
    .       ++num_chars;

    %%
    main()
            {
            yylex();
                    num_lines, num_chars );
            }

.fi
Этот сканер подсчитывает количество символов и количество
строк в своем вводе (он не выводит ничего, кроме
итогового отчета о подсчетах).
Первая строка
как внутри
.B yylex(),
так и в
.B main().
Есть два правила: одно
подсчет символов, и одно, которое сопоставляется с любым символом, кроме
.PP
Немного более сложный пример:
.nf

    /* сканер для игрушечного языка, подобного Паскалю */

    %{
    /* нужно для вызова atof() ниже */
    #include <math.h>
    %}

    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*

    %%

    {DIGIT}+    {
                        atoi( yytext ) );
                }

                        atof( yytext ) );
                }

    if|then|begin|end|procedure|function        {
                }




    [ \\t\\n]+          /* игнорировать пробельные символы */


    %%

    main( argc, argv )
    int argc;
    char **argv;
        {
        ++argv, --argc;  /* пропустить имя программы */
        if ( argc > 0 )
        else
                yyin = stdin;

        yylex();
        }

.fi
Это начало простого сканера для языка, подобного
Паскалю.
Он идентифицирует различные типы
.I токенов
и сообщает о том, что увидел.
.PP
Детали этого примера будут объяснены в следующих
разделах.
.ФОРМАТ ВХОДНОГО ФАЙЛА
.I flex
входной файл состоит из трех разделов, разделенных строкой, содержащей только
.B %%
:
.nf

    определения
    %%
    правила
    %%
    пользовательский код

.fi
Раздел
.I определения
содержит объявления простых
.I имен
определений для упрощения спецификации сканера, и объявления
.I стартовых условий,
которые объясняются в следующем разделе.
.PP
Определения имен имеют вид:
.nf

    имя определение

.fi
за которым следует ноль или более букв, цифр, '_' или '-' (дефис).
Определение начинается с первого не пробельного символа
после имени и продолжается до конца строки.
Например,
.nf

    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*

.fi
одна цифра, а
с последующими нулем или более буквами-или-цифрами.
Последующая ссылка на
.nf


.fi
идентична
.nf


.fi
и сопоставляет одну-или-более цифр, за которыми следует '.' и затем
ноль-или-более цифр.
.PP
Раздел
.I правил
.I flex
ввода содержит серию правил вида:
.nf

    образец   действие

.fi
где образец не должен иметь отступа, а действие должно начинаться
на той же строке.
.PP
См. ниже дальнейшее описание образцов и действий.
.PP
Наконец, раздел пользовательского кода просто копируется в
.B lex.yy.c
дословно.
Он используется для вспомогательных функций, которые вызывают или вызываются
сканером.
Наличие этого раздела необязательно;
если он отсутствует, второй
.B %%
во входном файле также может быть пропущен.
.PP
В разделах определений и правил любой
.I текст с отступом
или текст, заключенный в
.B %{
и
.B %},
копируется в вывод дословно (с удалением %{}).
%{} должны появляться без отступа на отдельных строках.
.PP
В разделе правил
любой текст с отступом или в %{}, появляющийся перед
первым правилом, может использоваться для объявления переменных,
локальных для функции сканирования, и (после объявлений)
кода, который должен выполняться всякий раз, когда функция сканирования входит.
Другой текст с отступом или в %{} в разделе правил все равно копируется в вывод,
но его значение плохо определено, и он вполне может вызвать ошибки времени компиляции
(эта возможность присутствует для
.I POSIX
совместимости; см. ниже другие такие возможности).
.PP
В разделе определений (но не в разделе правил)
неотступный комментарий (т.е. строка
.ОБРАЗЦЫ
Образцы во вводе записываются с использованием расширенного набора регулярных
выражений.
Это:
.nf

    x          сопоставить символ 'x'
    .          любой символ (байт), кроме новой строки
                 сопоставляет либо 'x', либо 'y', либо 'z'
                 'a', 'b', любую букву от 'j' до 'o',
                 или 'Z'
                 но не те, что в классе. В этом случае любой
                 символ КРОМЕ заглавной буквы.
    [^A-Z\\n]   любой символ КРОМЕ заглавной буквы или
                 новой строки
    r*         ноль или более r, где r - любое регулярное выражение
    r+         один или более r
    r{2,5}     от двух до пяти r
    r{2,}      два или более r
    r{4}       ровно 4 r
               (см. выше)
    \\X         если X это 'a', 'b', 'f', 'n', 'r', 't', или 'v',
                 тогда интерпретация ANSI-C \\x.
                 Иначе, литерал 'X' (используется для экранирования
                 операторов, таких как '*')
    \\0         символ NUL (код ASCII 0)
    \\123       символ с восьмеричным значением 123
    \\x2a       символ с шестнадцатеричным значением 2a
    (r)        сопоставить r; скобки используются для изменения
                 приоритета (см. ниже)


    rs         регулярное выражение r, за которым следует


    r|s        либо r, либо s


    r/s        r, но только если за ним следует s. Текст,
                 сопоставленный s, включается при определении
                 но затем возвращается во ввод перед
                 выполнением действия. Поэтому действие видит
                 только текст, сопоставленный r. Этот тип
                 (Есть некоторые комбинации r/s, которые flex
                 не может сопоставить правильно; см. заметки в разделе
                 Недостатки / Ошибки ниже относительно
    ^r         r, но только в начале строки (т.е.,
                 когда только начинается сканирование, или сразу после
                 сканирования новой строки).
    r$         r, но только в конце строки (т.е., просто

               то, что компилятор C, используемый для компиляции flex,
               интерпретирует как '\\n'; в частности, в некоторых DOS
               системах вы должны либо отфильтровать \\r во


    <s>r       r, но только в стартовом условии s (см.
                 ниже обсуждение стартовых условий)
    <s1,s2,s3>r
               то же, но в любом из стартовых условий s1,
                 s2 или s3
    <*>r       r в любом стартовом условии, даже исключительном.


    <<EOF>>    конец файла
    <s1,s2><<EOF>>
               конец файла, когда в стартовом условии s1 или s2

.fi
Обратите внимание, что внутри класса символов все операторы регулярных выражений
теряют свое специальное значение, кроме escape ('\\') и операторов
класса символов, '-', ']', и, в начале класса, '^'.
.PP
Перечисленные выше регулярные выражения сгруппированы в соответствии с
приоритетом, от наивысшего приоритета вверху до наименьшего внизу.
Сгруппированные вместе имеют одинаковый приоритет.
Например,
.nf

    foo|bar*

.fi
это то же самое, что
.nf

    (foo)|(ba(r*))

.fi
поскольку оператор '*' имеет более высокий приоритет, чем конкатенация,
а конкатенация выше, чем альтернация ('|').
Поэтому этот образец
сопоставляет
.I либо
.I либо
.nf

    foo|(bar)*

.fi
.nf

    (foo|bar)*

.fi
.PP
В дополнение к символам и диапазонам символов, классы символов
также могут содержать
.I выражения
класса символов.
Это выражения, заключенные в
.B [:
и
.B :]
разделители (которые сами должны появляться между '[' и ']'
класса символов; другие элементы также могут встречаться внутри класса символов).
Допустимые выражения:
.nf

    [:alnum:] [:alpha:] [:blank:]
    [:cntrl:] [:digit:] [:graph:]
    [:lower:] [:print:] [:punct:]
    [:space:] [:upper:] [:xdigit:]

.fi
Эти выражения обозначают набор символов, эквивалентный
соответствующей стандартной функции C
.B isXXX.
Например,
.B [:alnum:]
обозначает те символы, для которых
.B isalnum()
возвращает истину - т.е. любые алфавитно-цифровые.
Некоторые системы не предоставляют
.B isblank(),
поэтому flex определяет
.B [:blank:]
как пробел или табуляцию.
.PP
Например, следующие классы символов все эквивалентны:
.nf

    [[:alnum:]]
    [[:alpha:][:digit:]]
    [[:alpha:]0-9]
    [a-zA-Z0-9]

.fi
Если ваш сканер нечувствителен к регистру (флаг
.B \-i),
то
.B [:upper:]
и
.B [:lower:]
эквивалентны
.B [:alpha:].
.PP
Несколько замечаний об образцах:
.IP -
выше
.I будет сопоставлять символ новой строки
символы, явно присутствующие в отрицаемом классе символов
Это отличается от того, как многие другие инструменты регулярных
выражений обрабатывают отрицаемые классы символов, но, к сожалению,
несоответствие исторически укоренилось.
ввод, если только в вводе нет другой кавычки.
.IP -
Правило может иметь не более одного экземпляра завершающего контекста (оператор '/'
или оператор '$').
может встречаться только в начале образца, и, как и в случае с '/' и '$',
не может быть сгруппирован внутри скобок.
'^', который не встречается в
начале правила, или '$', который не встречается в конце
правила, теряет свои специальные свойства и рассматривается как обычный символ.
.IP
Следующие являются недопустимыми:
.nf

    foo/bar$
    <sc1>foo<sc2>bar

.fi
.IP
Следующие приведут к тому, что '$' или '^' будут рассматриваться как обычные символы:
.nf

    foo|(bar$)
    foo|^bar

.fi
может быть использован (специальное действие '|' объясняется ниже):
.nf

    foo      |
    bar$     /* действие помещается здесь */

.fi
Аналогичный трюк сработает для сопоставления foo или
bar-в-начале-строки.
.КАК СОПОСТАВЛЯЕТСЯ ВВОД
Когда сгенерированный сканер запущен, он анализирует свой ввод, ища
строки, которые соответствуют любому из его образцов.
Если он находит более
одного совпадения, он берет то, которое соответствует наибольшему количеству текста (для правил с
завершающим контекстом это включает длину завершающей части, даже
хотя она затем будет возвращена во ввод).
Если он находит два
или более совпадения одинаковой длины, то выбирается
правило, перечисленное первым во
.I flex
входном файле.
.PP
После определения совпадения текст, соответствующий совпадению
(называемый
.I токеном),
становится доступным в глобальном указателе на символ
.B yytext,
а его длина - в глобальном целом
.B yyleng.
.I Действие,
соответствующее сопоставленному образцу, затем выполняется (более
подробное описание действий следует), а затем оставшийся
ввод сканируется для другого совпадения.
.PP
Если совпадение не найдено, то выполняется
.I правило по умолчанию:
следующий символ во вводе считается сопоставленным и
копируется в стандартный вывод.
Таким образом, простейший допустимый
.I flex
ввод:
.nf

    %%

.fi
который генерирует сканер, который просто копирует свой ввод (по одному символу
за раз) в свой вывод.
.PP
Заметим, что
.B yytext
может быть определен двумя разными способами: либо как
.I указатель
на символ, либо как
.I массив
символов.
Вы можете контролировать, какое определение
.I flex
использует, включив одну из специальных директив
.B %pointer
или
.B %array
в первом (определения) разделе вашего flex ввода.
По умолчанию используется
.B %pointer,
если вы не используете опцию совместимости с lex
.B -l,
в этом случае
.B yytext
будет массивом.
Преимущество использования
.B %pointer
- существенно более быстрое сканирование и отсутствие переполнения буфера при сопоставлении
очень больших токенов (если только не закончится динамическая память).
Недостаток
в том, что вы ограничены в том, как ваши действия могут изменять
.B yytext
(см. следующий раздел), и вызовы функции
.B unput()
уничтожают текущее содержимое
.B yytext,
что может быть серьезной проблемой переноса при переходе между различными
версиями
.I lex.
.PP
Преимущество
.B %array
в том, что вы можете затем изменять
.B yytext
по своему усмотрению, и вызовы
.B unput()
не уничтожают
.B yytext
(см. ниже).
Кроме того, существующие программы
.I lex
иногда обращаются к
.B yytext
извне, используя объявления вида:
.nf
    extern char yytext[];
.fi
Это определение ошибочно при использовании с
.B %pointer,
но правильно для
.B %array.
.PP
.B %array
определяет
.B yytext
как массив из
.B YYLMAX
символов, который по умолчанию имеет довольно большое значение.
Вы можете изменить
размер, просто определив #define
.B YYLMAX
другим значением в первом разделе вашего
.I flex
ввода.
Как упоминалось выше, с
.B %pointer
yytext растет динамически, чтобы вместить большие токены.
Хотя это означает, что ваш сканер с
.B %pointer
может обрабатывать очень большие токены (например, сопоставляя целые блоки
комментариев), имейте в виду, что каждый раз, когда сканер должен изменить размер
.B yytext,
он также должен повторно сканировать весь токен с начала, поэтому сопоставление таких
токенов может оказаться медленным.
.B yytext
в настоящее время
.I не
растет динамически, если вызов
.B unput()
приводит к тому, что слишком много текста возвращается обратно; вместо этого возникает ошибка времени выполнения.
.PP
Также обратите внимание, что вы не можете использовать
.B %array
с классами сканеров на C++
(опция
.B c++;
см. ниже).
.ДЕЙСТВИЯ
Каждый образец в правиле имеет соответствующее действие, которое может быть любым
произвольным оператором C.
Образец заканчивается на первом неэкранированном
символе пробела; остаток строки является его действием.
Если
действие пусто, то при сопоставлении образца входной токен
просто отбрасывается.
Например, вот спецификация для программы
.nf

    %%

.fi
(Он скопирует все остальные символы ввода на вывод, поскольку
они будут сопоставлены правилом по умолчанию.)
.PP
Вот программа, которая сжимает множественные пробелы и табуляции до
одного пробела и отбрасывает пробельные символы, найденные в конце строки:
.nf

    %%
    [ \\t]+        putchar( ' ' );
    [ \\t]+$       /* игнорировать этот токен */

.fi
.PP
Если действие содержит '{', то действие продолжается до нахождения парной '}',
и действие может занимать несколько строк.
.I flex
знает о строках и комментариях C и не будет обманут фигурными скобками, найденными
внутри них, но также позволяет действиям начинаться с
.B %{
и будет считать действием весь текст до следующего
.B %}
(независимо от обычных скобок внутри действия).
.PP
.PP
Действия могут включать произвольный код C, включая
операторы
.B return
для возврата значения той функции, которая вызвала
.B yylex().
Каждый раз, когда
.B yylex()
вызывается, она продолжает обработку токенов с того места, где остановилась
в последний раз, пока либо не достигнет
конца файла, либо не выполнит return.
.PP
Действия могут свободно изменять
.B yytext,
кроме удлинения его (добавления
символов в его конец - они перезапишут последующие символы в
потоке ввода).
Однако это не применяется при использовании
.B %array
(см. выше); в этом случае
.B yytext
может быть свободно изменен любым способом.
.PP
Действия могут свободно изменять
.B yyleng,
за исключением того, что они не должны делать этого, если действие также включает использование
.B yymore()
(см. ниже).
.PP
Существует ряд специальных директив, которые могут быть включены в
действие:
.IP -
.B ECHO
копирует yytext в вывод сканера.
.IP -
.B BEGIN,
за которым следует имя стартового условия, помещает сканер в
соответствующее стартовое условие (см. ниже).
.IP -
.B REJECT
ввод (или префикс ввода).
Правило выбирается, как описано
.B yytext
и
.B yyleng
устанавливаются соответствующим образом.
Это может быть либо правило, которое сопоставило столько же текста,
сколько и изначально выбранное правило, но появилось позже в
.I flex
входном файле, либо правило, которое сопоставило меньше текста.
Например, следующее будет подсчитывать
.nf

            int word_count = 0;
    %%

    frob        special(); REJECT;
    [^ \\t\\n]+   ++word_count;

.fi
Без
.B REJECT,
сканер обычно выполняет только одно действие на токен.
Допускается несколько
.B REJECT,
каждый из которых находит следующее наилучшее правило к текущему
активному правилу.
Например, когда следующий сканер сканирует токен
.nf

    %%
    a        |
    ab       |
    abc      |
    abcd     ECHO; REJECT;
    .|\\n     /* поглотить любой несопоставленный символ */

.fi
(Первые три правила используют общее действие четвертого, поскольку они используют
специальное действие '|'.)
.B REJECT
- особенно дорогая возможность с точки зрения производительности сканера;
если она используется в
.I любом
из действий сканера, это замедлит
.I все
сопоставления сканера.
Кроме того,
.B REJECT
не может использоваться с опциями
.I -Cf
или
.I -CF
(см. ниже).
.IP
Также обратите внимание, что в отличие от других специальных действий,
.B REJECT
это
.I ветвление;
код, непосредственно следующий за ним в действии,
.I не
будет выполнен.
.IP -
.B yymore()
сообщает сканеру, что в следующий раз, когда он сопоставит правило, соответствующий
токен должен быть
.I добавлен
к текущему значению
.B yytext,
а не заменять его.
.nf

    %%
    mega-    ECHO; yymore();
    kludge   ECHO;

.fi
начало
.B yytext,
так что
.B ECHO
.PP
Два замечания относительно использования
.B yymore().
Во-первых,
.B yymore()
зависит от значения
.I yyleng,
правильно отражающего размер текущего токена, поэтому вы не должны
изменять
.I yyleng,
если используете
.B yymore().
Во-вторых, наличие
.B yymore()
в действии сканера влечет незначительное снижение производительности в
скорости сопоставления сканера.
.IP -
.B yyless(n)
возвращает все, кроме первых
.I n
символов текущего токена, обратно во входной поток, где они
будут повторно сканированы, когда сканер ищет следующее совпадение.
.B yytext
и
.B yyleng
корректируются соответствующим образом (например,
.B yyleng
теперь будет равно
.I n
).
.nf

    %%
    foobar    ECHO; yyless(3);
    [a-z]+    ECHO;

.fi
Аргумент 0 для
.B yyless
приведет к повторному сканированию всей текущей входной строки.
Если вы не
изменили, как сканер будет впоследствии обрабатывать свой ввод (используя
.B BEGIN,
например), это приведет к бесконечному циклу.
.PP
Обратите внимание, что
.B yyless
- это макрос и может использоваться только в файле ввода flex, а не из
других исходных файлов.
.IP -
.B unput(c)
помещает символ
.I c
обратно во входной поток.
Это будет следующий сканируемый символ.
Следующее действие возьмет текущий токен и заставит его
быть повторно отсканированным, заключенным в круглые скобки.
.nf

    {
    int i;
    /* Копировать yytext, потому что unput() портит yytext */
    char *yycopy = strdup( yytext );
    unput( ')' );
    for ( i = yyleng - 1; i >= 0; --i )
        unput( yycopy[i] );
    unput( '(' );
    free( yycopy );
    }

.fi
Обратите внимание, что поскольку каждый
.B unput()
помещает заданный символ обратно в
.I начало
входного потока, возврат строк должен выполняться в обратном порядке.
.PP
Важная потенциальная проблема при использовании
.B unput()
заключается в том, что если вы используете
.B %pointer
(по умолчанию), вызов
.B unput()
.I уничтожает
содержимое
.I yytext,
начиная с самого правого символа и поглощая по одному символу
влево с каждым вызовом.
Если вам нужно сохранить значение yytext
после вызова
.B unput()
(как в приведенном выше примере),
вы должны либо сначала скопировать его в другое место, либо построить свой сканер, используя
.B %array
вместо этого (см. Как сопоставляется ввод).
.PP
Наконец, обратите внимание, что вы не можете вернуть
.B EOF,
чтобы попытаться пометить входной поток символом конца файла.
.IP -
.B input()
читает следующий символ из входного потока.
Например,
следующий способ поглотить комментарии C:
.nf

    %%
                int c;

                for ( ; ; )
                    {
                    while ( (c = input()) != '*' &&
                            c != EOF )
                        ;    /* поглотить текст комментария */

                    if ( c == '*' )
                        {
                        while ( (c = input()) == '*' )
                            ;
                        if ( c == '/' )
                            break;    /* нашли конец */
                        }

                    if ( c == EOF )
                        {
                        break;
                        }
                    }
                }

.fi
(Обратите внимание, что если сканер скомпилирован с использованием
.B C++,
то
.B input()
вместо этого называется
.B yyinput(),
чтобы избежать конфликта имен с
.B C++
потоком с именем
.I input.)
.IP -
.B YY_FLUSH_BUFFER
очищает внутренний буфер сканера,
так что в следующий раз, когда сканер попытается сопоставить токен, он
сначала перезаполнит буфер, используя
.B YY_INPUT
(см. Генерируемый сканер ниже).
Это действие является частным случаем
более общей функции
.B yy_flush_buffer(),
описанной ниже в разделе Множественные входные буферы.
.IP -
.B yyterminate()
может использоваться вместо оператора return в действии.
Оно завершает
По умолчанию,
.B yyterminate()
также вызывается при обнаружении конца файла.
Это макрос и может быть переопределен.
.ГЕНЕРИРУЕМЫЙ СКАНЕР
Выход
.I flex
это файл
.B lex.yy.c,
который содержит функцию сканирования
.B yylex(),
ряд таблиц, используемых ею для сопоставления токенов, и несколько
вспомогательных функций и макросов.
По умолчанию,
.B yylex()
объявлена следующим образом:
.nf

    int yylex()
        {
        ... различные определения и действия здесь ...
        }

.fi
(Если ваша среда поддерживает прототипы функций, то она будет
Например, вы можете использовать:
.nf

    #define YY_DECL float lexscan( a, b ) float a, b;

.fi
чтобы дать функции сканирования имя
.I lexscan,
возвращающую float и принимающую два float в качестве аргументов.
Обратите внимание, что
если вы даете аргументы функции сканирования, используя
объявление функции в стиле K&R/без прототипа, вы должны завершить
определение точкой с запятой (;).
.PP
Всякий раз, когда
.B yylex()
вызывается, она сканирует токены из глобального входного файла
.I yyin
(который по умолчанию stdin).
Она продолжается до тех пор, пока либо не достигнет
конца файла (в этот момент она возвращает значение 0), либо
одно из ее действий не выполнит оператор
.I return.
.PP
Если сканер достигает конца файла, последующие вызовы не определены,
если либо
.I yyin
не будет направлен на новый входной файл (в этом случае сканирование продолжается из
этого файла), либо
не будет вызвана
.B yyrestart().
.B yyrestart()
принимает один аргумент, указатель
.B FILE *
(который может быть nil, если вы настроили
.B YY_INPUT
для сканирования из источника, отличного от
.I yyin),
и инициализирует
.I yyin
для сканирования из этого файла.
По сути, нет разницы между
просто присвоением
.I yyin
новому входному файлу или использованием
.B yyrestart()
для этого; последнее доступно для совместимости с предыдущими версиями
.I flex,
и потому что его можно использовать для переключения входных файлов в середине сканирования.
Его также можно использовать для отбрасывания текущего входного буфера, вызвав
его с аргументом
.I yyin;
но лучше использовать
.B YY_FLUSH_BUFFER
(см. выше).
Обратите внимание, что
.B yyrestart()
.I не
сбрасывает стартовое условие в
.B INITIAL
(см. Стартовые условия ниже).
.PP
Если
.B yylex()
останавливает сканирование из-за выполнения оператора
.I return
в одном из действий, сканер может быть вызван снова, и он
возобновит сканирование с того места, где остановился.
.PP
По умолчанию (и для эффективности) сканер использует
блочное чтение вместо простых вызовов
.I getc()
для чтения символов из
.I yyin.
Характер того, как он получает свой ввод, может контролироваться определением макроса
.B YY_INPUT.
Его действие - поместить до
.I max_size
символов в массив символов
.I buf
и вернуть в целочисленной переменной
.I result
либо
количество прочитанных символов, либо константу YY_NULL (0 в системах Unix)
для указания EOF.
По умолчанию YY_INPUT читает из
.PP
Пример определения YY_INPUT (в разделе
определений входного файла):
.nf

    %{
    #define YY_INPUT(buf,result,max_size) \\
        { \\
        int c = getchar(); \\
        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \\
        }
    %}

.fi
Это определение изменит обработку ввода на чтение
по одному символу за раз.
.PP
Когда сканер получает указание конца файла от YY_INPUT,
он затем проверяет функцию
.B yywrap().
Если
.B yywrap()
возвращает ложь (ноль), то предполагается, что
функция уже настроила
.I yyin
так, чтобы указывать на другой входной файл, и сканирование продолжается.
Если она возвращает
истину (не ноль), то сканер завершается, возвращая 0 своему
вызывающему.
Обратите внимание, что в любом случае стартовое условие остается неизменным;
оно
.I не
возвращается к
.B INITIAL.
.PP
Если вы не предоставите свою собственную версию
.B yywrap(),
то вы должны либо использовать
.B %option noyywrap
(в этом случае сканер ведет себя так, как будто
.B yywrap()
вернула 1), либо вы должны связывать с
.B \-ll
для получения стандартной версии функции, которая всегда возвращает 1.
.PP
Три функции доступны для сканирования из буферов в памяти, а не
файлов:
.B yy_scan_string(), yy_scan_bytes(),
и
.B yy_scan_buffer().
См. их обсуждение ниже в разделе Множественные входные буферы.
.PP
Сканер записывает свой вывод
.B ECHO
в глобальную переменную
.I yyout
(по умолчанию, stdout), которую пользователь может переопределить, просто
присвоив ей другой указатель
.B FILE.
.СТАРТОВЫЕ УСЛОВИЯ
.I flex
предоставляет механизм для условной активации правил.
Любое правило
Например,
.nf

                ...
                }

.fi
условие, и
.nf

    <INITIAL,STRING,QUOTE>\\.        { /* обработать escape ... */
                ...
                }

.fi
будет активным только тогда, когда текущее стартовое условие -
.PP
Стартовые условия
объявляются в разделе определений (первом) входного
файла с помощью строк без отступа, начинающихся с
.B %s
или
.B %x
с последующим списком имен.
Первое объявляет
.I включающие
стартовые условия, второе -
.I исключающие
стартовые условия.
Стартовое условие активируется с использованием действия
.B BEGIN.
До тех пор, пока следующее действие
.B BEGIN
не будет выполнено, правила с заданным стартовым
условием будут активны, а
правила с другими стартовыми условиями будут неактивны.
Если стартовое условие
.I включающее,
то правила без каких-либо стартовых условий также будут активны.
Если оно
.I исключающее,
то
.I только
правила, квалифицированные стартовым условием, будут активны.
Набор правил, зависящих от одного и того же исключающего стартового условия,
описывает сканер, независимый от любых других правил во
.I flex
вводе.
Из-за этого,
которые сканируют части ввода, синтаксически отличные
от остальных (например, комментарии).
.PP
Если различие между включающими и исключающими стартовыми условиями
все еще немного туманно, вот простой пример, иллюстрирующий
связь между ними.
Набор правил:
.nf

    %s example
    %%

    <example>foo   do_something();

    bar            something_else();

.fi
эквивалентен
.nf

    %x example
    %%

    <example>foo   do_something();

    <INITIAL,example>bar    something_else();

.fi
Без квалификатора
.B <INITIAL,example>
шаблон
.I bar
во втором примере не был бы активен (т.е. не мог бы сопоставляться),
когда в стартовом условии
.B example.
Если бы мы просто использовали
.B <example>
для квалификации
.I bar,
то он был бы активен только в
.B example
и не в
.B INITIAL,
тогда как в первом примере он активен в обоих, потому что в первом
примере стартовое условие
.B example
является
.I включающим
.B (%s)
стартовым условием.
.PP
Также обратите внимание, что специальный спецификатор стартового условия
.B <*>
сопоставляется с каждым стартовым условием.
Таким образом, приведенный выше пример также может быть записан как:
.nf

    %x example
    %%

    <example>foo   do_something();

    <*>bar    something_else();

.fi
.PP
Правило по умолчанию (для
.B ECHO
любого несопоставленного символа) остается активным в стартовых условиях.
Оно
эквивалентно:
.nf

    <*>.|\\n     ECHO;

.fi
.PP
.B BEGIN(0)
возвращает в исходное состояние, где активны только правила
без стартовых условий.
Это состояние также может быть обозначено как
.B BEGIN(INITIAL)
эквивалентно
.B BEGIN(0).
(Скобки вокруг имени стартового условия не требуются, но
считаются хорошим стилем.)
.PP
Действия
.B BEGIN
также могут быть заданы как код с отступом в начале
раздела правил.
Например, следующее заставит
.B yylex()
вызывается и глобальная переменная
.I enter_special
истинна:
.nf

            int enter_special;

    %x SPECIAL
    %%
            if ( enter_special )
                BEGIN(SPECIAL);

    <SPECIAL>blahblahblah
    ... далее следуют правила ...

.fi
.PP
Чтобы проиллюстрировать использование стартовых условий,
вот сканер, который предоставляет две различные интерпретации
По умолчанию он будет трактовать его как
Но если строка предшествует ранее в строке строке
он будет трактовать ее как один токен, число с плавающей точкой
123.456:
.nf

    %{
    #include <math.h>
    %}
    %s expect

    %%
    expect-floats        BEGIN(expect);

                        atof( yytext ) );
                }
    <expect>\\n           {
                /* это конец строки, поэтому
                 * мы вернемся к исходному состоянию,
                 * прежде чем распознавать дополнительные
                 * числа
                 */
                BEGIN(INITIAL);
                }

    [0-9]+      {
                        atoi( yytext ) );
                }


.fi
Вот сканер, который распознает (и отбрасывает) комментарии C, одновременно
поддерживая счетчик текущей строки ввода.
.nf

    %x comment
    %%
            int line_num = 1;


    <comment>[^*\\n]*        /* поглотить все, что не '*' */
    <comment>\\n             ++line_num;

.fi
Этот сканер прилагает некоторые усилия, чтобы сопоставить как можно больше
текста с каждым правилом.
В общем, при попытке написать
высокоскоростной сканер старайтесь сопоставить как можно больше в каждом правиле, так как
это дает большое преимущество.
.PP
Обратите внимание, что имена стартовых условий на самом деле являются целочисленными значениями и
могут храниться как таковые.
Таким образом, вышеприведенное может быть расширено
следующим образом:
.nf

    %x comment foo
    %%
            int line_num = 1;
            int comment_caller;

                 comment_caller = INITIAL;
                 BEGIN(comment);
                 }

    ...

                 comment_caller = foo;
                 BEGIN(comment);
                 }

    <comment>[^*\\n]*        /* поглотить все, что не '*' */
    <comment>\\n             ++line_num;

.fi
Кроме того, вы можете получить доступ к текущему стартовому условию, используя
целочисленный макрос
.B YY_START.
Например, вышеприведенные присваивания
.I comment_caller
могли бы быть записаны как
.nf

    comment_caller = YY_START;

.fi
Flex предоставляет
.B YYSTATE
как псевдоним для
.B YY_START
(поскольку именно это используется в AT&T
.I lex).
.PP
Обратите внимание, что стартовые условия не имеют своего собственного пространства имен; %s и %x
объявляют имена таким же образом, как и #define.
.PP
Наконец, вот пример того, как сопоставлять строки в стиле C, используя
исключающие стартовые условия, включая расширенные escape-последовательности (но
не включая проверку на слишком длинную строку):
.nf

    %x str

    %%
            char string_buf[MAX_STR_CONST];
            char *string_buf_ptr;



            BEGIN(INITIAL);
            *string_buf_ptr = '\\0';
            /* вернуть тип токена строковой константы и
             * значение синтаксическому анализатору
             */
            }

    <str>\\n        {
            /* ошибка - незавершенная строковая константа */
            /* сгенерировать сообщение об ошибке */
            }

    <str>\\\\[0-7]{1,3} {
            /* восьмеричная escape-последовательность */
            int result;


            if ( result > 0xff )
                    /* ошибка, константа вне допустимого диапазона */

            *string_buf_ptr++ = result;
            }

    <str>\\\\[0-9]+ {
            /* сгенерировать ошибку - неверная escape-последовательность; что-то
             * вроде '\\48' или '\\0777777'
             */
            }

    <str>\\\\n  *string_buf_ptr++ = '\\n';
    <str>\\\\t  *string_buf_ptr++ = '\\t';
    <str>\\\\r  *string_buf_ptr++ = '\\r';
    <str>\\\\b  *string_buf_ptr++ = '\\b';
    <str>\\\\f  *string_buf_ptr++ = '\\f';

    <str>\\\\(.|\\n)  *string_buf_ptr++ = yytext[1];

            char *yptr = yytext;

            while ( *yptr )
                    *string_buf_ptr++ = *yptr++;
            }

.fi
.PP
Часто, как в некоторых из приведенных выше примеров, вы оказываетесь пишущим
целую кучу правил, которым предшествуют одни и те же стартовые условия.
Flex делает это немного проще и чище, вводя понятие
.I области видимости
стартового условия.
Область видимости стартового условия начинается с:
.nf

    <SCs>{

.fi
где
.I SCs
- это список из одного или более стартовых условий.
Внутри области видимости стартового условия
каждое правило автоматически имеет префикс
.I <SCs>,
примененный к нему, пока не встретится
.I '}',
соответствующий начальному
.I '{'.
Таким образом, например,
.nf

    <ESC>{
    }

.fi
эквивалентно:
.nf


.fi
Области видимости стартовых условий могут быть вложенными.
.PP
Три функции доступны для управления стеками стартовых условий:
.TP
.B void yy_push_state(int new_state)
помещает текущее стартовое условие на вершину стека стартовых условий
и переключается на
.I new_state,
как если бы вы использовали
.B BEGIN new_state
(напомним, что имена стартовых условий также являются целыми числами).
.TP
.B void yy_pop_state()
извлекает вершину стека и переключается на нее через
.B BEGIN.
.TP
.B int yy_top_state()
возвращает вершину стека без изменения содержимого стека.
.PP
Стек стартовых условий растет динамически и поэтому не имеет встроенного
ограничения по размеру.
Если память исчерпана, выполнение программы аварийно завершается.
.PP
Чтобы использовать стеки стартовых условий, ваш сканер должен включать
директиву
.B %option stack
(см. Опции ниже).
.МНОЖЕСТВЕННЫЕ ВХОДНЫЕ БУФЕРЫ
требуют чтения из нескольких входных потоков.
Поскольку
.I flex
сканеры выполняют большое количество буферизации, нельзя управлять
тем, откуда будет прочитан следующий ввод, просто написав
.B YY_INPUT,
который чувствителен к контексту сканирования.
.B YY_INPUT
вызывается только тогда, когда сканер достигает конца своего буфера, что
что требует переключения источника ввода.
.PP
Для решения подобных проблем
.I flex
предоставляет механизм для создания и переключения между несколькими
входными буферами.
Входной буфер создается с помощью:
.nf

    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )

.fi
которая принимает указатель
.I FILE
и размер и создает буфер, связанный с заданным
файлом и достаточно большой, чтобы вместить
.I size
символов (в случае сомнений используйте
.B YY_BUF_SIZE
для размера).
Она возвращает дескриптор
.B YY_BUFFER_STATE,
который затем может быть передан другим функциям (см. ниже).
Тип
.B YY_BUFFER_STATE
- это указатель на непрозрачную структуру
.B struct yy_buffer_state,
поэтому вы можете безопасно инициализировать переменные YY_BUFFER_STATE значением
.B ((YY_BUFFER_STATE) 0),
если хотите, а также ссылаться на непрозрачную структуру, чтобы
правильно объявлять входные буферы в исходных файлах, отличных от
файла вашего сканера.
Обратите внимание, что указатель
.I FILE
в вызове
.B yy_create_buffer
используется только как значение
.I yyin,
видимое
.B YY_INPUT;
если вы переопределите
.B YY_INPUT
так, чтобы он больше не использовал
.I yyin,
то вы можете безопасно передать нулевой указатель
.I FILE
в
.B yy_create_buffer.
Вы выбираете конкретный буфер для сканирования с помощью:
.nf

    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )

.fi
переключает входной буфер сканера, чтобы последующие токены
поступали из
.I new_buffer.
Обратите внимание, что
.B yy_switch_to_buffer()
может использоваться yywrap() для настройки продолжения сканирования, вместо
открытия нового файла и направления
.I yyin
на него.
Также обратите внимание, что переключение источников ввода через
.B yy_switch_to_buffer()
или
.B yywrap()
.I не
изменяет стартовое условие.
.nf

    void yy_delete_buffer( YY_BUFFER_STATE buffer )

.fi
используется для освобождения памяти, связанной с буфером.
(
.B buffer
может быть nil, в этом случае функция ничего не делает.)
Вы также можете очистить текущее содержимое буфера с помощью:
.nf

    void yy_flush_buffer( YY_BUFFER_STATE buffer )

.fi
Эта функция отбрасывает содержимое буфера,
поэтому в следующий раз, когда сканер попытается сопоставить токен из
буфера, он сначала заполнит буфер заново, используя
.B YY_INPUT.
.PP
.B yy_new_buffer()
это псевдоним для
.B yy_create_buffer(),
предоставленный для совместимости с использованием C++
.I new
и
.I delete
для создания и уничтожения динамических объектов.
.PP
Наконец, макрос
.B YY_CURRENT_BUFFER
возвращает дескриптор
.B YY_BUFFER_STATE
текущего буфера.
.PP
Вот пример использования этих возможностей для написания сканера,
который раскрывает включаемые файлы (возможность
.B <<EOF>>
обсуждается ниже):
.nf

     * включаемого файла
     */
    %x incl

    %{
    #define MAX_INCLUDE_DEPTH 10
    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
    int include_stack_ptr = 0;
    %}

    %%
    include             BEGIN(incl);

    [a-z]+              ECHO;
    [^a-z\\n]*\\n?        ECHO;

    <incl>[ \\t]*      /* поглотить пробельные символы */
    <incl>[^ \\t\\n]+   { /* получили имя включаемого файла */
            if ( include_stack_ptr >= MAX_INCLUDE_DEPTH )
                {
                exit( 1 );
                }

            include_stack[include_stack_ptr++] =
                YY_CURRENT_BUFFER;


            if ( ! yyin )
                error( ... );

            yy_switch_to_buffer(
                yy_create_buffer( yyin, YY_BUF_SIZE ) );

            BEGIN(INITIAL);
            }

    <<EOF>> {
            if ( --include_stack_ptr < 0 )
                {
                yyterminate();
                }

            else
                {
                yy_delete_buffer( YY_CURRENT_BUFFER );
                yy_switch_to_buffer(
                     include_stack[include_stack_ptr] );
                }
            }

.fi
Три функции доступны для настройки входных буферов для
сканирования строк в памяти вместо файлов.
Все они создают
новый входной буфер для сканирования строки и возвращают соответствующий
дескриптор
.B YY_BUFFER_STATE
(который вы должны удалить с помощью
.B yy_delete_buffer(),
когда закончите с ним).
Они также переключаются на новый буфер, используя
.B yy_switch_to_buffer(),
поэтому следующий вызов
.B yylex()
начнет сканирование строки.
.TP
.B yy_scan_string(const char *str)
сканирует строку, завершающуюся NUL.
.TP
.B yy_scan_bytes(const char *bytes, int len)
сканирует
.I len
байт (включая возможно NUL),
начиная с расположения
.I bytes.
.PP
Обратите внимание, что обе эти функции создают и сканируют
.I копию
строки или байт.
(Это может быть желательно, поскольку
.B yylex()
изменяет содержимое буфера, который он сканирует.) Вы можете избежать
копирования, используя:
.TP
.B yy_scan_buffer(char *base, yy_size_t size)
которая сканирует на месте буфер, начинающийся с
.I base,
состоящий из
.I size
байт, последние два байта которых
.I должны
быть
.B YY_END_OF_BUFFER_CHAR
(ASCII NUL).
Эти последние два байта не сканируются; таким образом, сканирование
состоит из
.B base[0]
через
.B base[size-2],
включительно.
.IP
Если вы не настроите
.I base
таким образом (т.е. забудете последние два байта
.B YY_END_OF_BUFFER_CHAR),
то
.B yy_scan_buffer()
возвращает нулевой указатель вместо создания нового входного буфера.
.IP
Тип
.B yy_size_t
- это целочисленный тип, к которому вы можете привести целочисленное выражение,
отражающее размер буфера.
.ПРАВИЛА КОНЦА ФАЙЛА
действия, которые должны быть выполнены при обнаружении конца файла,
и yywrap() возвращает ненулевое значение (т.е. указывает,
что нет больше файлов для обработки).
Действие должно завершиться
выполнением одного из четырех действий:
.IP -
присвоением
.I yyin
новому входному файлу (в предыдущих версиях flex после присвоения
вы должны были вызывать специальное действие
.B YY_NEW_FILE;
это больше не требуется);
.IP -
выполнением оператора
.I return;
.IP -
выполнением специального действия
.B yyterminate();
.IP -
или переключением на новый буфер с помощью
.B yy_switch_to_buffer(),
как показано в примере выше.
.PP
Правила <<EOF>> не могут использоваться с другими
образцами; они могут быть квалифицированы только списком стартовых
условий.
Если задано неквалифицированное правило <<EOF>>, оно
применяется ко
.I всем
стартовым условиям, которые еще не имеют действий <<EOF>>.
Чтобы
указать правило <<EOF>> только для начального стартового условия, используйте
.nf

    <INITIAL><<EOF>>

.fi
.PP
Эти правила полезны для обнаружения таких вещей, как незакрытые комментарии.
Пример:
.nf

    %x quote
    %%

    ... другие правила для обработки кавычек ...

    <quote><<EOF>>   {
             yyterminate();
             }
    <<EOF>>  {
             if ( *++filelist )
             else
                yyterminate();
             }

.fi
.РАЗЛИЧНЫЕ МАКРОСЫ
Макрос
.B YY_USER_ACTION
может быть определен для предоставления действия,
которое всегда выполняется до действия сопоставленного правила.
Например,
его можно определить через #define для вызова функции, преобразующей yytext в нижний регистр.
Когда
.B YY_USER_ACTION
вызывается, переменная
.I yy_act
дает номер сопоставленного правила (правила нумеруются, начиная с 1).
Предположим, вы хотите профилировать, как часто сопоставляется каждое из ваших правил.
Следующее сработает:
.nf

    #define YY_USER_ACTION ++ctr[yy_act]

.fi
где
.I ctr
- это массив для хранения счетчиков для различных правил.
Обратите внимание, что макрос
.B YY_NUM_RULES
дает общее количество правил (включая правило по умолчанию, даже если
вы используете
.B \-s),
поэтому правильное объявление для
.I ctr
это:
.nf

    int ctr[YY_NUM_RULES];

.fi
.PP
Макрос
.B YY_USER_INIT
может быть определен для предоставления действия, которое всегда выполняется перед
первым сканированием (и до выполнения внутренних инициализаций сканера).
Например, его можно использовать для вызова функции чтения
таблицы данных или открытия файла журнала.
.PP
Макрос
.B yy_set_interactive(is_interactive)
может использоваться для контроля, считается ли текущий буфер
.I интерактивным.
Интерактивный буфер обрабатывается медленнее,
но должен использоваться, когда источник ввода сканера действительно
интерактивен, чтобы избежать проблем из-за ожидания заполнения буферов
(см. обсуждение флага
.B \-I
ниже).
Ненулевое значение
в вызове макроса помечает буфер как интерактивный, нулевое
значение как неинтерактивный.
Обратите внимание, что использование этого макроса переопределяет
.B %option interactive ,
.B %option always-interactive
или
.B %option never-interactive
(см. Опции ниже).
.B yy_set_interactive()
должен быть вызван до начала сканирования буфера, который
(или не) считается интерактивным.
.PP
Макрос
.B yy_set_bol(at_bol)
может использоваться для контроля, считается ли контекст сканирования текущего буфера
для следующего сопоставления токена как находящийся в начале строки.
Ненулевой аргумент макроса делает правила, закрепленные с
'^', активными, в то время как нулевой аргумент делает правила '^' неактивными.
.PP
Макрос
.B YY_AT_BOL()
возвращает истину, если следующий токен, отсканированный из текущего буфера,
будет иметь активные правила '^', и ложь в противном случае.
.PP
В сгенерированном сканере все действия собраны в одном большом
операторе switch и разделены с помощью
.B YY_BREAK,
который может быть переопределен.
каждого действия правила от следующего правила.
Переопределение
.B YY_BREAK
позволяет, например, пользователям C++
#define YY_BREAK, чтобы ничего не делать (при этом очень осторожно, что каждое
предупреждение о недостижимых операторах, потому что действие правила заканчивается на
.B YY_BREAK
недоступно.
.ЗНАЧЕНИЯ, ДОСТУПНЫЕ ПОЛЬЗОВАТЕЛЮ
Этот раздел суммирует различные значения, доступные пользователю
в действиях правил.
.IP -
.B char *yytext
содержит текст текущего токена.
Может быть изменен, но не удлинен
(вы не можете добавлять символы в конец).
.IP
Если в первом разделе описания сканера появляется специальная директива
.B %array,
то
.B yytext
вместо этого объявляется как
.B char yytext[YYLMAX],
где
.B YYLMAX
- это макроопределение, которое вы можете переопределить в первом разделе,
если вам не нравится значение по умолчанию (обычно 8 КБ).
Использование
.B %array
приводит к несколько более медленным сканерам, но значение
.B yytext
становится невосприимчивым к вызовам
.I input()
и
.I unput(),
которые потенциально разрушают его значение, когда
.B yytext
является указателем на символ.
Противоположностью
.B %array
является
.B %pointer,
который используется по умолчанию.
.IP
Вы не можете использовать
.B %array
при генерации классов сканеров на C++
(флаг
.B \-+
).
.IP -
.B int yyleng
содержит длину текущего токена.
.IP -
.B FILE *yyin
это файл, из которого по умолчанию
.I flex
читает.
Может быть переопределен, но это имеет смысл только до
начала сканирования или после обнаружения EOF.
Изменение его в середине сканирования приведет к неожиданным результатам, поскольку
.I flex
буферизует свой ввод; используйте
.B yyrestart()
вместо этого.
После завершения сканирования из-за обнаружения конца файла
вы можете присвоить
.I yyin
новый входной файл и затем снова вызвать сканер для продолжения сканирования.
.IP -
.B void yyrestart( FILE *new_file )
может быть вызван для направления
.I yyin
на новый входной файл.
Переключение на новый файл происходит немедленно
(любой ранее буферизованный ввод теряется).
Обратите внимание, что вызов
.B yyrestart()
с
.I yyin
в качестве аргумента, таким образом, отбрасывает текущий входной буфер и продолжает
сканирование того же входного файла.
.IP -
.B FILE *yyout
это файл, в который выполняются действия
.B ECHO.
Может быть переприсвоен пользователем.
.IP -
.B YY_CURRENT_BUFFER
возвращает дескриптор
.B YY_BUFFER_STATE
текущего буфера.
.IP -
.B YY_START
возвращает целочисленное значение, соответствующее текущему стартовому
условию.
Вы можете впоследствии использовать это значение с
.B BEGIN
для возврата к этому стартовому условию.
.ВЗАИМОДЕЙСТВИЕ С YACC
Одним из основных применений
.I flex
является сопровождение
.I yacc
генератора синтаксических анализаторов.
.I yacc
анализаторы ожидают вызова функции с именем
.B yylex()
для поиска следующего входного токена.
Функция должна
вернуть тип следующего токена, а также поместить любое связанное
значение в глобальную переменную
.B yylval.
Для использования
.I flex
с
.I yacc
необходимо указать опцию
.B \-d
для
.I yacc,
чтобы поручить ему сгенерировать файл
.B y.tab.h,
содержащий определения всех
.B %tokens,
появляющихся во входных данных
.I yacc.
Этот файл затем включается в сканер
.I flex.
часть сканера может выглядеть так:
.nf

    %{
    %}

    %%

    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;

.fi
.ОПЦИИ
.I flex
имеет следующие опции:
.TP
.B \-b, --backup
Генерировать информацию о резервном копировании в
.I lex.backup.
Это список состояний сканера, которые требуют резервного копирования,
и входные символы, на которых они это делают.
Добавляя правила,
можно удалить состояния резервного копирования.
Если
.I все
состояния резервного копирования устранены и используется
.B \-Cf
или
.B \-CF,
то сгенерированный сканер будет работать быстрее (см.
флаг
.B \-p
).
Только пользователи, которые хотят выжать последний цикл из своих
сканеров, должны беспокоиться об этой опции.
(См. раздел Соображения производительности ниже.)
.TP
.B \-c
это ничего не делающая, устаревшая опция, включенная для соответствия POSIX.
.TP
.B \-d, \-\-debug
заставляет сгенерированный сканер работать в
.I отладочном
режиме.
Всякий раз, когда образец распознан и глобальная переменная
.B yy_flex_debug
не равна нулю (что является значением по умолчанию),
сканер запишет в
.I stderr
строку вида:
.nf


.fi
Номер строки относится к местоположению правила в файле,
определяющем сканер (т.е. файле, который был подан на вход flex).
Сообщения также генерируются, когда сканер выполняет резервное копирование, принимает
правило по умолчанию, достигает конца своего входного буфера (или встречает
NUL; на данный момент эти два выглядят одинаково, насколько это касается сканера),
или достигает конца файла.
.TP
.B \-f, \-\-full
указывает
.I быстрый сканер.
Сжатие таблиц не выполняется, и stdio обходится.
Результат большой, но быстрый.
Эта опция эквивалентна
.B \-Cfr
(см. ниже).
.TP
.B \-h, \-\-help
выводит список
.I flex's
опций в
.I stdout
и затем завершает работу.
.B \-?
и
.B \-\-help
являются синонимами для
.B \-h.
.TP
.B \-i, \-\-case-insensitive
указывает
.I flex
генерировать
.I нечувствительный к регистру
сканер.
Регистр букв, заданных в образцах
.I flex
ввода, будет
игнорироваться, и токены во вводе будут сопоставляться независимо от регистра.
Сопоставленный текст, заданный в
.I yytext,
будет иметь сохраненный регистр (т.е. он не будет приведен к одному регистру).
.TP
.B \-l, \-\-lex\-compat
включает максимальную совместимость с оригинальной реализацией AT&T
.I lex.
Обратите внимание, что это не означает
.I полную
совместимость.
Использование этой опции стоит значительного количества
производительности, и она не может использоваться с опциями
.B \-+, -f, -F, -Cf,
или
.B -CF.
Подробности о предоставляемых совместимостях см. в разделе
Эта опция также приводит
к тому, что имя
.B YY_FLEX_LEX_COMPAT
будет определено через #define в сгенерированном сканере.
.TP
.B \-n
еще одна ничего не делающая, устаревшая опция, включенная только для
соответствия POSIX.
.TP
.B \-p, \-\-perf\-report
генерирует отчет о производительности в stderr.
Отчет состоит из комментариев относительно особенностей
.I flex
входного файла, которые вызовут серьезную потерю производительности в результирующем
сканере.
Если вы дадите флаг дважды, вы также получите комментарии относительно
особенностей, которые приводят к незначительным потерям производительности.
.IP
Обратите внимание, что использование
.B REJECT,
.B %option yylineno,
и переменного завершающего контекста (см. раздел Недостатки / Ошибки ниже)
влечет за собой существенное снижение производительности; использование
.I yymore(),
оператора
.B ^
и флага
.B \-I
влечет незначительное снижение производительности.
.TP
.B \-s, \-\-no\-default
вызывает подавление
.I правила по умолчанию
(что несопоставленный ввод сканера выводится в
.I stdout
).
Если сканер встречает ввод, который не
соответствует ни одному из его правил, он аварийно завершается с ошибкой.
Эта опция
полезна для нахождения дыр в наборе правил сканера.
.TP
.B \-t, \-\-stdout
указывает
.I flex
записывать сгенерированный сканер в стандартный вывод вместо
.B lex.yy.c.
.TP
.B \-v, \-\-verbose
указывает, что
.I flex
должен записать в
.I stderr
статистическую сводку относительно генерируемого сканера.
Большая часть статистики бессмысленна для случайного
пользователя
.I flex,
но первая строка идентифицирует версию
.I flex
(такая же, как сообщается
.B \-V
),
а следующая строка - флаги, используемые при генерации сканера, включая
те, которые включены по умолчанию.
.TP
.B \-w, \-\-nowarn
подавляет предупреждающие сообщения.
.TP
.B \-B, \-\-batch
указывает
.I flex
генерировать
.I пакетный
сканер, противоположный
.I интерактивным
сканерам, генерируемым
.B \-I
(см. ниже).
В общем, вы используете
.B \-B,
когда вы
.I уверены,
что ваш сканер никогда не будет использоваться интерактивно, и вы хотите
выжать
.I немного
больше производительности из него.
Если ваша цель вместо этого выжать
.I намного
больше производительности, вы должны использовать опции
.B \-Cf
или
.B \-CF
(обсуждаемые ниже), которые автоматически включают
.B \-B
в любом случае.
.TP
.B \-F, \-\-fast
указывает, что должно использоваться
.I быстрое
представление таблицы сканера (и stdio
обходится).
Это представление примерно так же быстро, как полное табличное представление
.B (-f),
и для некоторых наборов образцов будет значительно меньше (а для
других, больше).
.nf

    ...
    [a-z]+    return TOK_ID;

.fi
то вам лучше использовать полное табличное представление.
Если только
для обнаружения ключевых слов, вам лучше использовать
.B -F.
.IP
Эта опция эквивалентна
.B \-CFr
(см. ниже).
Она не может использоваться с
.B \-+.
.TP
.B \-I, \-\-interactive
указывает
.I flex
генерировать
.I интерактивный
сканер.
Интерактивный сканер - это тот, который заглядывает вперед, чтобы решить,
какой токен был сопоставлен, только если это абсолютно необходимо.
Оказывается, что
всегда заглядывать на один дополнительный символ вперед, даже если сканер уже
увидел достаточно текста, чтобы устранить неоднозначность текущего токена, немного быстрее, чем
заглядывать вперед только когда необходимо.
Но сканеры, которые всегда заглядывают вперед,
дают ужасную интерактивную производительность; например, когда пользователь вводит
новую строку, она не распознается как токен новой строки, пока они не введут
.I другой
токен, что часто означает ввод другой целой строки.
.IP
.I Flex
сканеры по умолчанию являются
.I интерактивными,
если вы не используете опции сжатия таблиц
.B \-Cf
или
.B \-CF
(см. ниже).
Это потому, что если вы ищете
высокую производительность, вы должны использовать одну из этих опций, так что если вы
не сделали этого,
.I flex
предполагает, что вы предпочтете пожертвовать немного производительности времени выполнения для интуитивного
интерактивного поведения.
Заметьте также, что вы
.I не можете
использовать
.B \-I
в сочетании с
.B \-Cf
или
.B \-CF.
Таким образом, эта опция не очень нужна; она включена по умолчанию для всех тех
случаев, в которых она разрешена.
.IP
Заметьте, что если
.B isatty()
возвращает ложь для ввода сканера, flex вернется в пакетный режим, даже если
был указан
.B \-I.
Чтобы принудительно использовать интерактивный режим независимо ни от чего, используйте
.B %option always-interactive
(см. Опции ниже).
.IP
Вы можете принудительно сделать сканер
.I не
интерактивным, используя
.B \-B
(см. выше).
.TP
.B \-L, \-\-noline
указывает
.I flex
не генерировать
.B #line
директивы.
Без этой опции,
.I flex
насыщает сгенерированный сканер
директивами #line, чтобы сообщения об ошибках в действиях были правильно
локализованы относительно либо исходного
.I flex
входного файла (если ошибки связаны с кодом во входном файле), либо
.B lex.yy.c
(если ошибки являются
.I виной flex
- вы должны сообщать об таких ошибках по адресу электронной почты,
данному ниже).
.TP
.B \-T, \-\-trace
заставляет
.I flex
работать в
.I трассировочном
режиме.
Он будет генерировать много сообщений в
.I stderr
касательно
формы ввода и результирующих недетерминированных и детерминированных
конечных автоматов.
Эта опция в основном для использования при сопровождении
.I flex.
.TP
.B \-V, \-\-version
печатает номер версии в
.I stdout
и завершает работу.
.B \-\-version
является синонимом для
.B \-V.
.TP
.B \-7, \-\-7bit
указывает
.I flex
генерировать 7-битный сканер, т.е. тот, который может распознавать только 7-битные
символы в своем вводе.
Преимущество использования
.B \-7
в том, что таблицы сканера могут быть вдвое меньше, чем те, которые генерируются
с использованием опции
.B \-8
(см. ниже).
Недостаток в том, что такие сканеры часто зависают
или аварийно завершаются, если их ввод содержит 8-битный символ.
.IP
Однако обратите внимание, что если вы не генерируете свой сканер, используя
.B \-Cf
или
.B \-CF
опции сжатия таблиц, использование
.B \-7
сохранит только небольшое количество табличного пространства и сделает ваш сканер
значительно менее переносимым.
Поведение
.I Flex
по умолчанию - генерировать 8-битный сканер, если вы не используете
.B \-Cf
или
.B \-CF,
в этом случае
.I flex
по умолчанию генерирует 7-битные сканеры, если ваш сайт не был всегда
настроен на генерацию 8-битных сканеров (как часто бывает
с не-США сайтами).
Вы можете определить, сгенерировал ли flex 7-битный
или 8-битный сканер, проверив сводку флагов в выводе
.B \-v,
как описано выше.
.IP
Обратите внимание, что если вы используете
.B \-Cfe
или
.B \-CFe
(эти опции сжатия таблиц, но также использующие классы эквивалентности, как
обсуждается ниже), flex по-прежнему по умолчанию генерирует 8-битный
сканер, поскольку обычно с этими опциями сжатия полные 8-битные таблицы
не намного дороже, чем 7-битные таблицы.
.TP
.B \-8, \-\-8bit
указывает
.I flex
генерировать 8-битный сканер, т.е. тот, который может распознавать 8-битные
символы.
Этот флаг нужен только для сканеров, сгенерированных с использованием
.B \-Cf
или
.B \-CF,
поскольку в противном случае flex по умолчанию генерирует 8-битный сканер в любом случае.
.IP
См. обсуждение
.B \-7
выше для поведения по умолчанию flex и компромиссов между 7-битными
и 8-битными сканерами.
.TP
.B \-+, \-\-c++
указывает, что вы хотите, чтобы flex генерировал класс сканера на C++.
См. раздел Генерация сканеров на C++ ниже для
подробностей.
.TP
.B \-C[aefFmr]
контролирует степень сжатия таблиц и, более общо, компромиссы
между маленькими сканерами и быстрыми сканерами.
.IP
.B \-Ca, \-\-align
генерирует сканер для более быстрого выполнения, потому что элементы
таблиц лучше выровнены для доступа к памяти и вычислений.
На некоторых
RISC архитектурах выборка и манипуляция длинными словами более эффективны,
чем с единицами меньшего размера, такими как короткие слова.
Эта опция может
удвоить размер таблиц, используемых вашим сканером.
.IP
.B \-Ce, \-\-ecs
направляет
.I flex
строить
.I классы эквивалентности,
т.е. наборы символов,
которые имеют одинаковые лексические свойства (например, если единственное
появление цифр во
.I flex
вводе находится в классе символов
в том же классе эквивалентности).
Классы эквивалентности обычно дают
драматическое сокращение размеров конечного файла таблиц/объектов (обычно
в 2-5 раз) и довольно дешевы с точки зрения производительности (один поиск в
массиве на символ).
.IP
.B \-Cf
указывает, что должны быть сгенерированы
.I полные
таблицы сканера -
.I flex
не должен сжимать
таблицы, используя преимущества схожих функций перехода для
различных состояний.
.IP
.B \-CF
указывает, что должно использоваться альтернативное быстрое представление сканера (описанное
выше под флагом
.B \-F
).
Эта опция не может использоваться с
.B \-+.
.IP
.B \-Cm, \-\-meta-ecs
направляет
.I flex
строить
.I метаклассы эквивалентности,
которые являются наборами классов эквивалентности (или символов, если классы
эквивалентности не используются), которые обычно используются вместе.
Метаклассы эквивалентности
часто дают большой выигрыш при использовании сжатых таблиц, но они
поиск в массиве на символ).
.IP
.B \-Cr, \-\-read
вызывает в сгенерированном сканере
.I обход
использования стандартной библиотеки ввода-вывода (stdio) для ввода.
Вместо вызова
.B fread()
или
.B getc(),
сканер будет использовать
системный вызов
.B read(),
что приводит к выигрышу в производительности, который варьируется от системы
к системе, но в целом, вероятно, незначителен, если вы также не используете
.B \-Cf
или
.B \-CF.
Использование
.B \-Cr
может вызвать странное поведение, если, например, вы читаете из
.I yyin
используя stdio до вызова сканера (потому что сканер пропустит
любой текст, который ваши предыдущие чтения оставили в буфере ввода stdio).
.IP
.B \-Cr
не имеет эффекта, если вы определяете
.B YY_INPUT
(см. Генерируемый сканер выше).
.IP
Одинокий
.B \-C
указывает, что таблицы сканера должны быть сжаты, но ни
классы эквивалентности, ни метаклассы эквивалентности не должны использоваться.
.IP
Опции
.B \-Cf
или
.B \-CF
и
.B \-Cm
не имеют смысла вместе - нет возможности для метаклассов эквивалентности,
если таблица не сжимается.
В остальном опции
могут свободно смешиваться и являются кумулятивными.
.IP
Настройка по умолчанию -
.B \-Cem,
которая указывает, что
.I flex
должен генерировать классы эквивалентности
и метаклассы эквивалентности.
Эта настройка обеспечивает наивысшую степень сжатия таблиц.
Вы можете пожертвовать
скоростью выполнения сканеров в обмен на большие таблицы, причем
следующее, как правило, верно:
.nf

    самый медленный и самый маленький
          -Cem
          -Cm
          -Ce
          -C
          -C{f,F}e
          -C{f,F}
          -C{f,F}a
    самый быстрый и самый большой

.fi
Заметьте, что сканеры с самыми маленькими таблицами обычно генерируются и
компилируются быстрее всего, поэтому
во время разработки вы обычно захотите использовать настройки по умолчанию, максимальное
сжатие.
.IP
.B \-Cfe
часто является хорошим компромиссом между скоростью и размером для рабочих
сканеров.
.TP
.B \-ooutput, \-\-outputfile=FILE
указывает flex записать сканер в файл
.B output
вместо
.B lex.yy.c.
Если вы объединяете
.B \-o
с опцией
.B \-t,
то сканер записывается в
.I stdout,
но его
.B #line
директивы (см. опцию
.B \\-L
выше) ссылаются на файл
.B output.
.TP
.B \-Pprefix, \-\-prefix=STRING
изменяет префикс по умолчанию,
используемый
.I flex
для всех глобально видимых имен переменных и функций, на
.I prefix.
Например,
.B \-Pfoo
изменяет имя
.B yytext
на
.B footext.
Он также изменяет имя файла вывода по умолчанию с
.B lex.yy.c
на
.B lex.foo.c.
Вот все имена, на которые это влияет:
.nf

    yy_create_buffer
    yy_delete_buffer
    yy_flex_debug
    yy_init_buffer
    yy_flush_buffer
    yy_load_buffer_state
    yy_switch_to_buffer
    yyin
    yyleng
    yylex
    yylineno
    yyout
    yyrestart
    yytext
    yywrap

.fi
(Если вы используете сканер на C++, то только
.B yywrap
и
.B yyFlexLexer
затронуты.)
Внутри самого сканера вы по-прежнему можете ссылаться на глобальные переменные
и функции, используя любую версию их имени; но внешне они
имеют измененное имя.
.IP
Эта опция позволяет вам легко связывать несколько
.I flex
программ в один исполняемый файл.
Обратите внимание, однако, что использование этой опции также переименовывает
.B yywrap(),
так что теперь вы
.I должны
либо
предоставить свою собственную (соответствующим образом названную) версию функции для вашего
сканера, либо использовать
.B %option noyywrap,
поскольку связывание с
.B \-ll
больше не предоставляет ее по умолчанию.
.TP
.B \-Sskeleton_file, \-\-skel=FILE
переопределяет файл скелета по умолчанию, из которого
.I flex
конструирует свои сканеры.
Вам никогда не понадобится эта опция, если вы не занимаетесь
сопровождением или разработкой
.I flex.
.TP
.B \-X, \-\-posix\-compat
максимальная совместимость с POSIX lex.
.TP
.B \-\-yylineno
отслеживать количество строк в yylineno.
.TP
.B \-\-yyclass=NAME
имя класса C++.
.TP
.B \-\-header\-file=FILE
создать заголовочный файл C в дополнение к сканеру.
.TP
.B \-\-tables\-file[=FILE]
записать таблицы в FILE.
.TP
.B \\-Dmacro[=defn]
#define macro defn (по умолчанию defn это '1').
.TP
.B \-R,  \-\-reentrant
генерировать реентерабельный сканер на C
.TP
.B \-\-bison\-bridge
сканер для чистого анализатора bison.
.TP
.B \-\-bison\-locations
включать поддержку yylloc.
.TP
.B \-\-stdinit
инициализировать yyin/yyout в stdin/stdout.
.TP
.B \-\-noansi\-definitions старые определения функций.
.TP
.B \-\-noansi\-prototypes
пустой список параметров в прототипах.
.TP
.B \-\-nounistd
не включать <unistd.h>.
.TP
.B \-\-noFUNCTION
не генерировать определенную FUNCTION.
.PP
.I flex
также предоставляет механизм для управления опциями внутри
спецификации сканера, а не из командной строки flex.
Это делается путем включения
директив
.B %option
в первом разделе спецификации сканера.
Вы можете указать несколько опций одной директивой
.B %option,
и несколько директив в первом разделе вашего файла ввода flex.
.PP
Большинство опций задаются просто как имена, опционально предваренные словом
Ряд из них эквивалентны флагам flex или их отрицанию:
.nf

    7bit            -7 опция
    8bit            -8 опция
    align           -Ca опция
    backup          -b опция
    batch           -B опция
    c++             -+ опция

    caseful или
    case-sensitive  противоположность -i (по умолчанию)

    case-insensitive или
    caseless        -i опция

    debug           -d опция
    default         противоположность -s опции
    ecs             -Ce опция
    fast            -F опция
    full            -f опция
    interactive     -I опция
    lex-compat      -l опция
    meta-ecs        -Cm опция
    perf-report     -p опция
    read            -Cr опция
    stdout          -t опция
    verbose         -v опция
    warn            противоположность -w опции


.fi
Некоторые
.B %option
предоставляют возможности, иначе недоступные:
.TP
.B always-interactive
указывает flex генерировать сканер, который всегда считает свой ввод
Обычно, для каждого нового входного файла сканер вызывает
.B isatty()
в попытке определить,
является ли источник ввода сканера интерактивным и, следовательно, должен читаться
по одному символу за раз.
Когда используется эта опция, однако, такой
вызов не делается.
.TP
.B main
указывает flex предоставить программу
.B main()
по умолчанию для сканера, которая просто вызывает
.B yylex().
Эта опция подразумевает
.B noyywrap
(см. ниже).
.TP
.B never-interactive
указывает flex генерировать сканер, который никогда не считает свой ввод
.B isatty()).
Это противоположность
.B always-interactive.
.TP
.B stack
включает использование стеков стартовых условий (см. Стартовые условия выше).
.TP
.B stdinit
если установлено (т.е.
.B %option stdinit
),
инициализирует
.I yyin
и
.I yyout
в
.I stdin
и
.I stdout,
вместо значения по умолчанию
.I nil.
Некоторые существующие программы
.I lex
зависят от этого поведения, даже несмотря на то, что оно не соответствует
ANSI C, который не требует, чтобы
.I stdin
и
.I stdout
были константами времени компиляции.
.TP
.B yylineno
указывает
.I flex
генерировать сканер, который поддерживает номер текущей строки,
прочитанной из его ввода, в глобальной переменной
.B yylineno.
Эта опция подразумевается
.B %option lex-compat.
.TP
.B yywrap
если не установлено (т.е.
.B %option noyywrap
),
заставляет сканер не вызывать
.B yywrap()
при конце файла, а просто предполагать, что больше нет
файлов для сканирования (пока пользователь не направит
.I yyin
на новый файл и не вызовет
.B yylex()
снова).
.PP
.I flex
сканирует ваши действия правил, чтобы определить, используете ли вы
.B REJECT
или
.B yymore().
Опции
.B reject
и
.B yymore
доступны для переопределения его решения о том, используете ли вы эти
опции, либо путем установки их (например,
.B %option reject
), чтобы указать, что возможность действительно используется, либо
снятия их, чтобы указать, что она фактически не используется
(например,
.B %option noyymore
).
.PP
Три опции принимают строковые значения, разделенные '=':
.nf


.fi
эквивалентно
.B -oABC,
а
.nf


.fi
эквивалентно
.B -PXYZ.
Наконец,
.nf


.fi
применяется только при генерации сканера на C++ (
.B \-+
опция).
Он информирует
.I flex,
что вы вывели
.B foo
как подкласс
.B yyFlexLexer,
так что
.I flex
поместит ваши действия в функцию-член
.B foo::yylex()
вместо
.B yyFlexLexer::yylex().
Он также генерирует функцию-член
.B yyFlexLexer::yylex(),
которая выдает ошибку времени выполнения (вызывая
.B yyFlexLexer::LexerError()
) при вызове.
См. Генерация сканеров на C++, ниже, для дополнительной информации.
.PP
Ряд опций доступен для пуристов lint, которые хотят подавить
появление ненужных функций в сгенерированном сканере.
Каждая из следующих, если не установлена
(например,
.B %option nounput
), приводит к тому, что соответствующая функция не появляется в
сгенерированном сканере:
.nf

    input, unput
    yy_push_state, yy_pop_state, yy_top_state
    yy_scan_buffer, yy_scan_bytes, yy_scan_string

.fi
(хотя
.B yy_push_state()
и друзья не появятся в любом случае, если вы не используете
.B %option stack
).
.СООБРАЖЕНИЯ ПРОИЗВОДИТЕЛЬНОСТИ
Основная цель проектирования
.I flex
- генерировать высокопроизводительные сканеры.
Он был оптимизирован
для хорошей работы с большими наборами правил.
Помимо влияния на скорость сканера от сжатия таблиц
опциями
.B \-C,
обсуждаемыми выше,
существует ряд опций/действий, которые снижают производительность.
Они перечислены от самых дорогих к самым дешевым:
.nf

    REJECT
    %option yylineno
    произвольный завершающий контекст

    наборы образцов, требующие резервного копирования
    %array
    %option interactive
    %option always-interactive

    оператор '^' начала строки
    yymore()

.fi
причем первые три довольно дороги, а последние два
довольно дешевы.
Также обратите внимание, что
.B unput()
реализована как вызов функции, который потенциально выполняет довольно много
работы, в то время как
.B yyless()
- довольно дешевый макрос; поэтому если нужно просто вернуть некоторый избыточный текст, который вы
отсканировали, используйте
.B yyless().
.PP
.B REJECT
следует избегать любой ценой, когда важна производительность.
Это особенно дорогая опция.
.PP
Избавление от резервного копирования является грязным и часто может потребовать огромного
объема работы для сложного сканера.
В принципе, начинают с использования
флага
.B \-b
для генерации файла
.I lex.backup.
Например, на ввод
.nf

    %%
    foo        return TOK_KEYWORD;
    foobar     return TOK_KEYWORD;

.fi
файл выглядит так:
.nf

    State #6 is non-accepting -
     associated rule line numbers:
           2       3
     out-transitions: [ o ]
     jam-transitions: EOF [ \\001-n  p-\\177 ]

    State #8 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ a ]
     jam-transitions: EOF [ \\001-`  b-\\177 ]

    State #9 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ r ]
     jam-transitions: EOF [ \\001-q  s-\\177 ]

    Compressed tables always back up.

.fi
Первые несколько строк говорят нам, что есть состояние сканера, в
котором он может выполнить переход по 'o', но не по любому другому
символу, и что в этом состоянии в настоящее время отсканированный текст не соответствует
ни одному правилу.
Состояние возникает при попытке сопоставить правила, найденные
в строках 2 и 3 входного файла.
Если сканер находится в этом состоянии и затем читает
что-то отличное от 'o', ему придется выполнить резервное копирование, чтобы найти
правило, которое сопоставляется.
Немного поразмыслив, можно увидеть, что это должно быть состояние
Когда это произошло,
если увиден любой символ, кроме другого 'o', сканеру придется
выполнить резервное копирование, чтобы просто сопоставить 'f' (правилом по умолчанию).
.PP
Комментарий относительно State #8 указывает на проблему с
Действительно, на любом символе, кроме
был отсканирован, и 'r' не следует.
.PP
Последний комментарий напоминает нам, что нет смысла идти на
все хлопоты по удалению резервного копирования из правил, если
мы не используем
.B \-Cf
или
.B \-CF,
поскольку при этом нет выигрыша в производительности со сжатыми сканерами.
.PP
.nf

    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    fooba       |
    foob        |
    fo          {
                /* ложная тревога, не действительно ключевое слово */
                return TOK_ID;
                }

.fi
.PP
Устранение резервного копирования среди списка ключевых слов также может быть
.nf

    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    [a-z]+      return TOK_ID;

.fi
Обычно это лучшее решение, когда оно уместно.
.PP
Сообщения о резервном копировании имеют тенденцию каскадироваться.
Со сложным набором правил нередко получаются сотни
сообщений.
Если можно их расшифровать, часто
требуется только дюжина или около того правил, чтобы устранить резервное копирование (хотя
легко ошибиться и иметь ошибочное правило, случайно сопоставляющее
допустимый токен).
Возможная будущая особенность
.I flex
- автоматическое добавление правил для устранения резервного копирования.
.PP
Важно помнить, что вы получаете преимущества от устранения
резервного копирования только если устраняете
.I каждое
его проявление.
Оставление всего одного означает, что вы ничего не выигрываете.
.PP
.I Переменный
завершающий контекст (где как ведущая, так и завершающая части не имеют
фиксированной длины) влечет почти такую же потерю производительности, как и
.B REJECT
(т.е. существенную).
Поэтому, когда возможно, правило вида:
.nf

    %%
    mouse|rat/(cat|dog)   run();

.fi
лучше записать как:
.nf

    %%
    mouse/cat|dog         run();
    rat/cat|dog           run();

.fi
или как
.nf

    %%
    mouse|rat/cat         run();
    mouse|rat/dog         run();

.fi
Обратите внимание, что здесь специальное действие '|' не
обеспечивает никакой экономии и может даже ухудшить ситуацию (см.
Недостатки / Ошибки ниже).
.LP
Другая область, где пользователь может повысить производительность сканера
(и которая легче реализуется), возникает из того факта, что
чем длиннее сопоставляемые токены, тем быстрее будет работать сканер.
Это потому, что с длинными токенами обработка большинства входных
символов происходит в (коротком) внутреннем цикле сканирования и
не часто требует дополнительной работы по настройке
окружения сканирования (например,
.B yytext
) для действия.
Вспомните сканер для комментариев C:
.nf

    %x comment
    %%
            int line_num = 1;


    <comment>[^*\\n]*
    <comment>\\n             ++line_num;

.fi
Его можно ускорить, записав так:
.nf

    %x comment
    %%
            int line_num = 1;


    <comment>[^*\\n]*
    <comment>[^*\\n]*\\n      ++line_num;

.fi
Теперь вместо того, чтобы каждая новая строка требовала обработки другого
сохранять сопоставленный текст как можно длиннее.
Обратите внимание, что
.I добавление
правил
.I не
замедляет сканер! Скорость сканера не зависит
от количества правил или (с учетом соображений, данных в
начале этого раздела) насколько сложны правила с
точки зрения операторов, таких как '*' и '|'.
.PP
Последний пример ускорения сканера: предположим, вы хотите сканировать
файл, содержащий идентификаторы и ключевые слова, по одному на строку
и без других посторонних символов, и распознавать все
ключевые слова.
Естественный первый подход:
.nf

    %%
    asm      |
    auto     |
    break    |
    ... и т.д. ...
    volatile |
    while    /* это ключевое слово */

    .|\\n     /* это не ключевое слово */

.fi
Чтобы устранить обратное отслеживание, введите правило-ловушку:
.nf

    %%
    asm      |
    auto     |
    break    |
    ... и т.д. ...
    volatile |
    while    /* это ключевое слово */

    [a-z]+   |
    .|\\n     /* это не ключевое слово */

.fi
Теперь, если гарантировано, что есть ровно одно слово на строку,
то мы можем уменьшить общее количество сопоставлений вдвое,
объединив распознавание новых строк с распознаванием других
токенов:
.nf

    %%
    asm\\n    |
    auto\\n   |
    break\\n  |
    ... и т.д. ...
    volatile\\n |
    while\\n  /* это ключевое слово */

    [a-z]+\\n |
    .|\\n     /* это не ключевое слово */

.fi
Здесь нужно быть осторожным, так как мы теперь снова ввели резервное копирование
в сканер.
В частности, хотя
.I мы
знаем, что во входном потоке никогда не будет никаких символов,
кроме букв или новых строк,
.I flex
не может это понять, и он будет планировать возможность необходимости резервного копирования,
если встретится что-то отличное от новой строки или буквы.
Ранее он бы
Чтобы устранить возможность резервного копирования,
мы могли бы либо продублировать все правила, но без конечных новых строк, либо,
поскольку мы никогда не ожидаем встретить такой ввод и поэтому не заботимся о том,
как он классифицируется, мы можем ввести еще одно правило-ловушку, на этот
раз без новой строки:
.nf

    %%
    asm\\n    |
    auto\\n   |
    break\\n  |
    ... и т.д. ...
    volatile\\n |
    while\\n  /* это ключевое слово */

    [a-z]+\\n |
    [a-z]+   |
    .|\\n     /* это не ключевое слово */

.fi
Скомпилированный с
.B \-Cf,
это настолько быстро, насколько можно заставить
.I flex
сканер работать для этой конкретной задачи.
.PP
Последнее замечание:
.I flex
медленно работает при сопоставлении NUL'ов, особенно когда токен содержит
несколько NUL'ов.
Лучше писать правила, которые сопоставляют
.I короткие
объемы текста, если ожидается, что текст часто будет включать NUL'ы.
.PP
Еще одно последнее замечание относительно производительности: как упоминалось выше в разделе
Как сопоставляется ввод, динамическое изменение размера
.B yytext
для размещения огромных токенов является медленным процессом, потому что в настоящее время требует, чтобы
(огромный) токен повторно сканировался с начала.
Таким образом, если производительность
символов/токен.
.ГЕНЕРАЦИЯ СКАНЕРОВ НА C++
.I flex
предоставляет два различных способа генерации сканеров для использования с C++.
Первый способ - просто скомпилировать сканер, сгенерированный
.I flex,
используя компилятор C++ вместо компилятора C.
Вы не должны столкнуться
с какими-либо ошибками компиляции (пожалуйста, сообщайте о любых, которые найдете, по адресу электронной почты,
указанному в разделе Автор ниже).
Затем вы можете использовать код C++ в своих действиях правил вместо кода C.
Обратите внимание, что источник ввода по умолчанию для вашего сканера остается
.I yyin,
а вывод по умолчанию по-прежнему осуществляется в
.I yyout.
Обе эти переменные остаются
указателями
.I FILE *
, а не потоками C++
.I streams.
.PP
Вы также можете использовать
.I flex
для генерации класса сканера на C++, используя опцию
.B \-+
(или, что эквивалентно,
.B %option c++),
которая автоматически указывается, если имя исполняемого файла flex
заканчивается на '+', например
.I flex++.
При использовании этой опции flex по умолчанию генерирует сканер в файл
.B lex.yy.cc
вместо
.B lex.yy.c.
Сгенерированный сканер включает заголовочный файл
.I FlexLexer.h,
который определяет интерфейс для двух классов C++.
.PP
Первый класс,
.B FlexLexer,
предоставляет абстрактный базовый класс, определяющий общий интерфейс класса сканера.
Он предоставляет следующие функции-члены:
.TP
.B const char* YYText()
возвращает текст последнего сопоставленного токена, эквивалент
.B yytext.
.TP
.B int YYLeng()
возвращает длину последнего сопоставленного токена, эквивалент
.B yyleng.
.TP
.B int lineno() const
возвращает текущий номер строки ввода
(см.
.B %option yylineno
),
или
.B 1,
если
.B %option yylineno
не использовалась.
.TP
.B void set_debug( int flag )
устанавливает флаг отладки для сканера, эквивалентно присваиванию
.B yy_flex_debug
(см. раздел Опции выше).
Обратите внимание, что вы должны собрать сканер, используя
.B %option debug,
чтобы включить в него информацию отладки.
.TP
.B int debug() const
возвращает текущее значение флага отладки.
.PP
Также предоставляются функции-члены, эквивалентные
.B yy_switch_to_buffer(),
.B yy_create_buffer()
(хотя первый аргумент - это указатель на объект
.B std::istream*,
а не
.B FILE*),
.B yy_flush_buffer(),
.B yy_delete_buffer(),
и
.B yyrestart()
(опять же, первый аргумент - указатель на объект
.B std::istream*).
.PP
Второй класс, определенный в
.I FlexLexer.h,
это
.B yyFlexLexer,
который является производным от
.B FlexLexer.
Он определяет следующие дополнительные функции-члены:
.TP
.B
yyFlexLexer( std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0 )
конструирует объект
.B yyFlexLexer,
используя заданные потоки для ввода и вывода.
Если не указано, потоки по умолчанию равны
.B cin
и
.B cout,
соответственно.
.TP
.B virtual int yylex()
выполняет ту же роль, что и
.B yylex()
для обычных сканеров flex: она сканирует входной поток, потребляя
токены, пока действие правила не вернет значение.
Если вы выводите подкласс
.B S
из
.B yyFlexLexer
и хотите получить доступ к функциям-членам и переменным
.B S
внутри
.B yylex(),
то вам нужно использовать
чтобы сообщить
.I flex,
что вы будете использовать этот подкласс вместо
.B yyFlexLexer.
В этом случае вместо генерации
.B yyFlexLexer::yylex()
.I flex
генерирует
.B S::yylex()
(а также генерирует фиктивную функцию
.B yyFlexLexer::yylex(),
которая вызывает
.B yyFlexLexer::LexerError()
при вызове).
.TP
.B
virtual void switch_streams(std::istream* new_in = 0,
.B
std::ostream* new_out = 0)
переназначает
.B yyin
на
.B new_in
(если не nil)
и
.B yyout
на
.B new_out
(также если не nil), удаляя предыдущий входной буфер, если
.B yyin
переназначен.
.TP
.B
int yylex( std::istream* new_in, std::ostream* new_out = 0 )
сначала переключает входные потоки через
.B switch_streams( new_in, new_out )
и затем возвращает значение
.B yylex().
.PP
Кроме того,
.B yyFlexLexer
определяет следующие защищенные виртуальные функции, которые вы можете переопределить
в производных классах, чтобы настроить сканер:
.TP
.B
virtual int LexerInput( char* buf, int max_size )
читает до
.B max_size
символов в
.B buf
и возвращает количество прочитанных символов.
Чтобы указать конец ввода, верните 0 символов.
.B \-B
и
.B \-I
флаги) определяют макрос
.B YY_INTERACTIVE.
Если вы переопределяете
.B LexerInput()
и вам нужно выполнять разные действия в зависимости от того, может ли
сканер сканировать интерактивный источник ввода, вы можете
проверить наличие этого имени через
.B #ifdef.
.TP
.B
virtual void LexerOutput( const char* buf, int size )
записывает
.B size
символов из буфера
.B buf,
в
.B yyout.
Нужна для того, чтобы сканер мог записывать свой вывод
.B ECHO;
при желании вы можете переопределить эту функцию в другом потоке.
Обратите внимание, что эта функция
.I вызывается только
когда сканер пишет в
.B yyout
(а не, например, в файл).
Это потому, что выходные действия сканера
не ограничены выходом в
.B yyout.
Однако вы можете переопределить
.B yyFlexLexer::LexerOutput()
для записи в произвольное место.
Обратите внимание, что сканер может писать NUL'ы; возможно, ваш
переопределенная функция LexerOutput() позволила бы писать NUL'ы в соответствующие места.
Правила сканера могут сопоставлять текст с NUL'ами в них.
.TP
.B
virtual void LexerError( const char* msg )
сообщает о фатальной ошибке.
Стандартная версия этой функции записывает сообщение в поток
.B cerr
и завершает работу.
.PP
Обратите внимание, что объект
.B yyFlexLexer
содержит
.I все
состояние сканирования.
Таким образом, вы можете использовать такие объекты для создания реентерабельных сканеров.
Вы можете создавать несколько экземпляров одного и того же класса
.B yyFlexLexer,
а также можете комбинировать несколько классов сканеров на C++ вместе
в одной программе, используя опцию
.B \-P,
обсуждаемую выше.
.PP
Наконец, обратите внимание, что возможность
.B %array
недоступна для классов сканеров на C++; вы должны использовать
.B %pointer
(по умолчанию).
.PP
Вот пример простого сканера на C++:
.nf

        // Пример использования класса сканера C++ flex.

    %{
    int mylineno = 0;
    %}


    ws      [ \\t]+

    alpha   [A-Za-z]
    dig     [0-9]
    name    ({alpha}|{dig}|\\$)({alpha}|{dig}|[_.\\-/$])*
    num1    [-+]?{dig}+\\.?([eE][-+]?{dig}+)?
    num2    [-+]?{dig}*\\.{dig}+([eE][-+]?{dig}+)?
    number  {num1}|{num2}

    %%

    {ws}    /* пропустить пробелы и табуляции */

            int c;

            while((c = yyinput()) != 0)
                {
                if(c == '\\n')
                    ++mylineno;

                else if(c == '*')
                    {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                    }
                }
            }


    \\n        mylineno++;



    %%

    int main( int /* argc */, char** /* argv */ )
        {
        FlexLexer* lexer = new yyFlexLexer;
        while(lexer->yylex() != 0)
            ;
        return 0;
        }
.fi
Если вы хотите создать несколько (разных) классов лексеров, вы используете
флаг
.B \-P
(или опцию
.B prefix=
), чтобы переименовать каждый
.B yyFlexLexer
в какой-нибудь другой
.B xxFlexLexer.
Затем вы можете включить
.B <FlexLexer.h>
в ваши другие исходные файлы по одному разу на класс лексера, сначала переименовав
.B yyFlexLexer
следующим образом:
.nf

    #undef yyFlexLexer
    #define yyFlexLexer xxFlexLexer
    #include <FlexLexer.h>

    #undef yyFlexLexer
    #define yyFlexLexer zzFlexLexer
    #include <FlexLexer.h>

.fi
если, например, вы использовали
для одного из ваших сканеров и
для другого.
.PP
ВАЖНО: текущая форма класса сканирования является
.I экспериментальной
и может значительно измениться между основными выпусками.
.НЕСОВМЕСТИМОСТИ С LEX И POSIX
.I flex
это переписывание инструмента AT&T Unix
.I lex
(две реализации не разделяют никакого кода, хотя),
с некоторыми расширениями и несовместимостями, обе из которых
важны для тех, кто хочет писать сканеры, приемлемые
для любой реализации.
Flex полностью соответствует спецификации
.I lex
POSIX, за исключением того, что при использовании
.B %pointer
(по умолчанию) вызов
.B unput()
уничтожает содержимое
.B yytext,
что противоречит спецификации POSIX.
.PP
В этом разделе мы обсуждаем все известные области несовместимости
между flex, AT&T lex и спецификацией POSIX.
.PP
Опция
.B \-l
.I flex
включает максимальную совместимость с оригинальной реализацией AT&T
.I lex,
ценой значительной потери производительности сгенерированного сканера.
Мы отмечаем ниже, какие несовместимости можно преодолеть
с помощью опции
.B \-l.
.PP
.I flex
полностью совместим с
.I lex
за следующими исключениями:
.IP -
Не документированная внутренняя переменная сканера
.I lex
.B yylineno
не поддерживается, если не используется
.B \-l
или
.B %option yylineno.
.IP
.B yylineno
должна поддерживаться на основе буфера, а не на основе сканера
(одна глобальная переменная).
.IP
.B yylineno
не является частью спецификации POSIX.
.IP -
Функция
.B input()
не может быть переопределена, хотя она может вызываться для чтения символов,
следующих за тем, что было сопоставлено правилом.
Если
.B input()
встречает конец файла, выполняется обычная обработка
.B yywrap().
``Настоящий'' конец файла возвращается функцией
.B input()
как
.I EOF.
.IP
Ввод вместо этого контролируется определением макроса
.B YY_INPUT.
.IP
Ограничение
.I flex,
что
.B input()
не может быть переопределена, соответствует спецификации POSIX,
которая просто не определяет никакого способа управления
вводом сканера, кроме как путем начального присваивания
.I yyin.
.IP -
Функция
.B unput()
не может быть переопределена.
Это ограничение соответствует POSIX.
.IP -
.I flex
сканеры не так реентерабельны, как
.I lex
сканеры.
В частности, если у вас есть интерактивный сканер и
обработчик прерывания, который выполняет длинный переход из сканера, и
сканер затем вызывается снова, вы можете получить следующее
сообщение:
.nf

    fatal flex scanner internal error--end of buffer missed

.fi
Чтобы повторно войти в сканер, сначала используйте
.nf

    yyrestart( yyin );

.fi
Обратите внимание, что этот вызов отбросит любой буферизованный ввод; обычно это
не проблема с интерактивным сканером.
.IP
Также обратите внимание, что классы сканеров flex на C++
.I являются
реентерабельными, поэтому если использование C++ является для вас вариантом, вам следует использовать
их вместо этого.
.IP -
.B output()
не поддерживается.
Вывод макроса
.B ECHO
осуществляется в указатель файла
.I yyout
(по умолчанию
.I stdout
).
.IP
.B output()
не является частью спецификации POSIX.
.IP -
.I lex
не поддерживает исключающие стартовые условия (%x), хотя они
есть в спецификации POSIX.
.IP -
При расширении определений
.I flex
заключает их в круглые скобки.
В lex следующее:
.nf

    NAME    [A-Z][A-Z0-9]*
    %%
    %%

.fi
и приоритет таков, что '?' ассоциируется с
С
.I flex
правило будет расширено до
.IP
Обратите внимание, что если определение начинается с
.B ^
или заканчивается
.B $,
то оно
.I не
расширяется с круглыми скобками, чтобы позволить этим операторам появляться в
определениях без потери их специальных значений.
Но операторы
.B <s>, /,
и
.B <<EOF>>
не могут использоваться в определении
.I flex.
.IP
Использование
.B \-l
дает поведение
.I lex
без круглых скобок вокруг определения.
.IP
Спецификация POSIX заключается в том, что определение должно быть заключено в круглые скобки.
.IP -
Некоторые реализации
.I lex
позволяют действию правила начинаться на отдельной строке, если шаблон правила
имеет завершающие пробелы:
.nf

    %%
    foo|bar<пробел здесь>
      { foobar_action(); }

.fi
.I flex
не поддерживает эту возможность.
.IP -
Опция
.I lex
.B %r
(генерировать сканер Ratfor) не поддерживается.
Она не является частью
спецификации POSIX.
.IP -
После вызова
.B unput()
.I yytext
не определен до следующего сопоставления токена, если сканер
не был построен с использованием
.B %array.
Это не так в случае
.I lex
или спецификации POSIX.
Опция
.B \-l
устраняет эту несовместимость.
.IP -
Приоритет оператора
.B {}
(числовой диапазон) отличается.
.I lex
.I flex
Последнее соответствует спецификации POSIX.
.IP -
Приоритет оператора
.B ^
отличается.
.I lex
.I flex
Последнее соответствует спецификации POSIX.
.IP -
Специальные объявления размера таблицы, такие как
.B %a,
поддерживаемые
.I lex,
не требуются для сканеров
.I flex;
.I flex
игнорирует их.
.IP -
Имя
.B FLEX_SCANNER
определено через #define, чтобы сканеры могли быть написаны для использования с
.I flex
или
.I lex.
Сканеры также включают
.B YY_FLEX_MAJOR_VERSION
и
.B YY_FLEX_MINOR_VERSION,
указывающие, какая версия
.I flex
сгенерировала сканер
(например, для выпуска 2.5, эти определения будут 2 и 5
соответственно).
.PP
Следующие возможности
.I flex
не включены в
.I lex
или спецификацию POSIX:
.nf

    Сканеры на C++
    %option
    области видимости стартовых условий
    стеки стартовых условий
    интерактивные/неинтерактивные сканеры
    yy_scan_string() и подобные
    yyterminate()
    yy_set_interactive()
    yy_set_bol()
    YY_AT_BOL()
    <<EOF>>
    <*>
    YY_DECL
    YY_START
    YY_USER_ACTION
    YY_USER_INIT
    #line директивы
    %{} вокруг действий
    множественные действия на строке

.fi
плюс почти все флаги flex.
Последняя возможность в списке относится к тому факту, что с
.I flex
вы можете поместить несколько действий на одну строку, разделенных
точками с запятой, в то время как с
.I lex
следующее
.nf

    foo    handle_foo(); ++num_foos_seen;

.fi
(довольно удивительно) обрезается до
.nf

    foo    handle_foo();

.fi
.I flex
не обрезает действие.
Действия, не заключенные в
фигурные скобки, просто завершаются в конце строки.
.ДИАГНОСТИКА
.I предупреждение, правило не может быть сопоставлено
указывает, что данное правило
не может быть сопоставлено, потому что оно следует за другими правилами, которые будут
всегда сопоставлять тот же текст, что и оно.
.nf

    [a-z]+    got_identifier();
    foo       got_foo();

.fi
Использование
.B REJECT
в сканере подавляет это предупреждение.
.PP
.I предупреждение,
дана опция
.B \-s
но правило по умолчанию может быть сопоставлено
означает, что возможно (возможно, только в определенном стартовом условии),
что правило по умолчанию (сопоставить любой одиночный символ) является единственным,
которое будет сопоставлять определенный ввод.
Поскольку был задан
.B \-s,
предположительно, это не предполагалось.
.PP
.I reject_used_but_not_detected undefined
или
.I yymore_used_but_not_detected undefined -
Эти ошибки могут возникать во время компиляции.
Они указывают, что сканер использует
.B REJECT
или
.B yymore()
но что
.I flex
не заметил этот факт, то есть
.I flex
просканировал первые два раздела в поисках вхождений этих действий
и не нашел ни одного, но каким-то образом вы протащили их (через include
файл, например).
Используйте
.B %option reject
или
.B %option yymore
чтобы указать flex, что вы действительно используете эти возможности.
.PP
.I flex scanner jammed -
сканер, скомпилированный с
.B \-s,
встретил входную строку, которая не соответствовала
ни одному из его правил.
Эта ошибка также может возникать из-за внутренних проблем.
.PP
.I token too large, exceeds YYLMAX -
ваш сканер использует
.B %array
и одно из его правил сопоставило строку длиннее, чем константа
.B YYLMAX
(8 КБ по умолчанию).
Вы можете увеличить значение,
определив #define
.B YYLMAX
в разделе определений вашего
.I flex
ввода.
.PP
.I scanner requires \-8 flag to
.I use the character 'x' -
Ваша спецификация сканера включает распознавание 8-битного символа
.I 'x',
и вы не указали флаг \-8, и ваш сканер по умолчанию стал 7-битным,
потому что вы использовали опции сжатия таблиц
.B \-Cf
или
.B \-CF.
См. обсуждение флага
.B \-7
для подробностей.
.PP
.I flex scanner push-back overflow -
вы использовали
.B unput()
для возврата такого количества текста, что буфер сканера не смог удержать
как возвращенный текст, так и текущий токен в
.B yytext.
В идеале сканер должен динамически изменять размер буфера в этом случае, но на
данный момент он этого не делает.
.PP
.I
input buffer overflow, can't enlarge buffer because scanner uses REJECT -
сканер работал над сопоставлением чрезвычайно большого токена и нуждался
в расширении входного буфера.
Это не работает со сканерами, которые используют
.B
REJECT.
.PP
.I
fatal flex scanner internal error--end of buffer missed -
Это может произойти в сканере, который повторно входит после того, как long-jump
выпрыгнул (или перепрыгнул) кадр активации сканера.
Перед повторным входом в сканер используйте:
.nf

    yyrestart( yyin );

.fi
или, как отмечено выше, переключитесь на использование класса сканера на C++.
.PP
.I too many start conditions in <> construct! -
вы перечислили больше стартовых условий в конструкции <>, чем существует (так
что вы должны были перечислить хотя бы одно из них дважды).
.ФАЙЛЫ
.TP
.B \-ll
библиотека, с которой должны быть связаны сканеры.
.TP
.I lex.yy.c
сгенерированный сканер (называется
.I lexyy.c
в некоторых системах).
.TP
.I lex.yy.cc
сгенерированный класс сканера на C++, при использовании
.B -+.
.TP
.I <FlexLexer.h>
заголовочный файл, определяющий базовый класс сканера на C++,
.B FlexLexer,
и его производный класс,
.B yyFlexLexer.
.TP
.I flex.skl
скелет сканера.
Этот файл используется только при сборке flex, а не при выполнении flex.
.TP
.I lex.backup
информация о резервном копировании для флага
.B \-b
(называется
.I lex.bck
в некоторых системах).
.НЕДОСТАТКИ / ОШИБКИ
Некоторые шаблоны с завершающим контекстом
не могут быть правильно сопоставлены и генерируют
Это шаблоны, где окончание
первой части правила совпадает с началом второй
начало завершающего контекста.
(Обратите внимание, что проект
POSIX
указывает, что текст, сопоставленный такими шаблонами, не определен.)
.PP
Для некоторых правил с завершающим контекстом части, которые на самом деле имеют фиксированную длину,
не распознаются как таковые, что приводит к упомянутой выше потере производительности.
считаются переменной длины.
.PP
Комбинирование завершающего контекста со специальным действием '|' может привести к тому, что
.I фиксированный
завершающий контекст превратится в более дорогой
.I переменный
завершающий контекст.
Например, в следующем:
.nf

    %%
    abc      |
    xyz/def

.fi
.PP
Использование
.B unput()
делает недействительными yytext и yyleng, если не использована директива
.B %array
или опция
.B \-l.
.PP
Сопоставление с образцом NUL'ов существенно медленнее, чем сопоставление других
символов.
.PP
Динамическое изменение размера входного буфера медленное, так как требует повторного сканирования
всего текста, сопоставленного до сих пор текущим (обычно огромным) токеном.
.PP
Из-за буферизации ввода и упреждающего чтения вы не можете смешивать
вызовы routines из <stdio.h>, такие как, например,
.B getchar(),
с правилами
.I flex
и ожидать, что это будет работать.
Вызывайте
.B input()
вместо этого.
.PP
Общее количество записей в таблице, перечисленное флагом
.B \-v,
исключает количество записей в таблице, необходимых для определения,
какое правило было сопоставлено.
Количество записей равно
количеству состояний DFA, если сканер не использует
.B REJECT,
и несколько больше, чем количество состояний, если использует.
.PP
.B REJECT
не может использоваться с опциями
.B \-f
или
.B \-F.
.PP
Внутренние алгоритмы
.I flex
нуждаются в документации.
.СМ. ТАКЖЕ
lex(1), yacc(1), sed(1), awk(1).
.PP
Джон Левин, Тони Мейсон и Даг Браун,
.I Lex & Yacc,
O'Reilly and Associates.
Обязательно получите 2-е издание.
.PP
М. Э. Леск и Э. Шмидт,
.I LEX \- Генератор лексических анализаторов
.PP
Альфред Ахо, Рави Сети и Джеффри Ульман,
.I Компиляторы: Принципы, Методы и Инструменты,
Addison-Wesley (1986).
Описывает методы сопоставления с образцом, используемые
.I flex
(детерминированные конечные автоматы).
.АВТОРЫ
Верн Паксон, с помощью множества идей и большого вдохновения от
Ван Якобсон.
Оригинальная версия от Джефа Посканзера.
Быстрое табличное
представление является частичной реализацией дизайна, выполненного Ван
Якобсон.
Реализация была выполнена Кевином Гонгом и Верном Паксоном.
.PP
Спасибо многим
бета-тестерам, рецензентам и вкладчикам
.I flex,
особенно Франсуа Пинару,
Кейси Лидому,
Роберту Абрамовицу,
Стену Адерманну, Терри Аллену, Дэвиду Баркеру-Плумеру, Джону Басраю,
Нилу Беккеру, Нельсону Х.Ф. Биби, benson@odi.com,
Карлу Берри, Питеру А. Биготу, Саймону Бланшару,
Кейту Бостику, Фредерику Брему, Иану Брокбанку, Кин Чо, Нику Кристоферу,
Брайану Клэпперу, Дж.Т. Конклину,
Джейсону Кофлину, Биллу Коксу, Нику Кропперу, Дейву Кертису, Скотту Дэвиду
Дэниелсу, Крису Г. Деметриу, Тео де Раадту,
Майку Донахью, Чаку Дуссету, Тому Эпперли, Лео Эскину,
Крису Фэйлору, Крису Флаттерсу, Джону Форресту, Джеффри Фридлу,
Джо Гайде, Кавеху Р. Гази, Вольфгангу Глунцу,
Эрику Голдману, Кристоферу М. Гулду, Ульриху Грепелю, Пиру Грибелю,
Яну Гайичу, Чарльзу Хемфиллу, НОРО Хидео,
Яркко Хиетаниеми, Скотту Хофманну,
Джеффу Хонигу, Дане Хьюдсу, Эрику Хьюзу, Джону Интерранте,
Кериелю Джейкобсу, Михалу Ягерманну, Сакари Джаловааре, Джеффри Р. Джонсу,
Генри Юнгсту, Клаусу Кемпфу, Джонатану И. Каменсу, Терренсу О Кейну,
Амиру Кацу, ken@ken.hilco.com, Кевину Б. Кенни,
Стиву Киршу, Винфриду Кенигу, Марку Коле, Рональду Лампрехту,
Грегу Ли, Рохану Ленарду, Крейгу Лересу, Джону Левину, Стиву Лиддлу,
Дэвиду Лоффредо, Майку Лонгу,
Мохамеду эль Лози, Брайану Мадсену, Мальте, Джо Маршаллу,
Бенгту Мартенссону, Крису Меткалфу,
Люку Мьюберну, Джиму Мейерингу, Р. Александру Миловски, Эрику Наггуму,
Г.Т. Николу, Лэндону Ноллу, Джеймсу Нордби, Марку Нозеллу,
Ричарду Онемусу, Карстену Панке,
Свену Панне, Роланду Пешу, Вальтеру Пелиссеро, Гомону
Пьеру, Эсмонду Питту, Джефу Посканзеру, Джо Раме, Ярмо Райхе,
Фредерику Рамбо, Пэту Рэнкину, Рику Ричардсону,
Кевину Роджерсу, Каю Уве Роммелю, Джиму Роскинду, Альберто Сантини,
Андреасу Шереру, Дарреллу Шибелю, Рафу Шитетекату,
Дагу Шмидту, Филиппу Шнобелену, Андреасу Швабу,
Ларри Швиммеру, Алексу Сигелю, Эккехарду Штольцу, Яну-Эрику Стрёмквисту,
Майку Стампу, Полу Стюарту, Дэйву Таллману, Иану Лэнсу Тейлору,
Крису Тьюолту, Ричарду М. Тимонею, Джоди Цай,
Полу Туиненге, Гэри Вейку, Фрэнку Уэйли, Герхарду Вильгельмсу, Кенту Уильямсу, Кену
Япу, Рону Зеллару, Натану Зелле, Дэвиду Цуну,
и тем, чьи имена ускользнули от моих скромных
навыков архивации почты, но чей вклад все равно высоко ценится.
.PP
Спасибо Кейту Бостику, Джону Форресту, Ною Фридману,
Джону Гилмору, Крейгу Лересу, Джону Левину, Бобу Малкахи, Г.Т.
Николу, Франсуа Пинару, Ричу Зальцу и Ричарду Столлману за помощь с различными
проблемами распространения.
.PP
Спасибо Эсмонду Питту и Эрлу Хортону за поддержку 8-битных символов; 
Бенсону Маргулису и Фреду Бёрку за поддержку C++; Кенту Уильямсу и Тому
Эпперли за поддержку классов C++; Ове Эверлиду за поддержку NUL'ов; и
Эрику Хьюзу за поддержку множественных буферов.
.PP
Эта работа была в основном выполнена, когда я был с группой Real Time Systems Group
в Lawrence Berkeley Laboratory в Беркли, Калифорния.
Большое спасибо всем там за поддержку, которую я получил.
.PP
Отправляйте комментарии на vern@ee.lbl.gov.
