.\" Copyright (c) 1985, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\" Copyright (c) 2002 - 2015 Tony Finch <dot@dotat.at>.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Dave Yost. It was rewritten to support ANSI C by Tony Finch.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" FRDP path ./contrib/unifdef/unifdef.1
.\" FRDP githash 049b7608f41bf4e93ac6de718c45bef261f6977d
.\" FRDP hash256 e53ab388b46d19d9b3ecd87b76409e25082e00d5c5056cb3714bc7edbe7de610
.Dd 3 декабря 2015
.Dt UNIFDEF 1 PRM
.Sh ИМЯ
.Nm unifdef , unifdefall
.Nd удаление условных директив препроцессора из кода
.Sh СИНТАКСИС
.Nm
.Op Fl bBcdehKkmnsStV
.Op Fl I Ns Ar путь
.Op Fl [i]D Ns Ar символ Ns Op = Ns Ar значение
.Op Fl [i]U Ns Ar символ
.Ar ...
.Op Fl f Ar файл_определений
.Op Fl x Bro Ar 012 Brc
.Op Fl M Ar расширение_резервной_копии
.Op Fl o Ar выходной_файл
.Op Ar входной_файл ...
.Nm unifdefall
.Op Fl I Ns Ar путь
.Ar ...
.Ar файл
.Sh ОПИСАНИЕ
Утилита
.Nm
выборочно обрабатывает условные директивы
.Xr cpp 1 .
Она удаляет из файла как сами директивы,
так и любой дополнительный текст, который они предписывают удалить,
в остальном оставляя файл без изменений.
.Pp
Утилита
.Nm
действует на строки
.Ic #if , #ifdef , #ifndef ,
.Ic #elif , #else ,
и
.Ic #endif ,
используя макросы, заданные в опциях командной строки
.Fl D
и
.Fl U
или в файлах определений
.Fl f .
Директива обрабатывается,
если спецификации макросов достаточны для получения
определенного значения ее управляющего выражения.
Если результат ложный,
директива и последующие строки, находящиеся под ее контролем, удаляются.
Если результат истинный,
удаляется только директива.
Директивы
.Ic #ifdef
или
.Ic #ifndef
пропускаются без изменений,
если их управляющий макрос не указан.
Любое управляющее выражение
.Ic #if
или
.Ic #elif ,
имеющее неизвестное значение или которое
.Nm
не может разобрать, пропускается без изменений.
По умолчанию
.Nm
игнорирует строки
.Ic #if
и
.Ic #elif
с константными выражениями;
ей можно указать обрабатывать их с помощью флага
.Fl k
в командной строке.
.Pp
Утилита понимает часто используемое подмножество
синтаксиса выражений для строк
.Ic #if
и
.Ic #elif :
целочисленные константы,
целочисленные значения макросов, определенных в командной строке,
оператор
.Fn defined ,
операторы
.Ic \&! , ~ , -
(унарные),
.Ic * , / , % , + , - ,
.Ic < , <= , > , >= , == , != , & , ^ , \&| ,
.Ic && , || ,
и выражения в скобках.
Деление на ноль трактуется как неизвестное значение.
Для оператора
.Ic &&
используется особый вид вычисления:
если любой операнд определенно ложен, то результат ложен,
даже если значение другого операнда неизвестно.
Аналогично,
если любой операнд
.Ic ||
определенно истинен, то результат истинен.
.Pp
При вычислении выражения
.Nm
не раскрывает макросы предварительно.
Значение макроса должно быть простым числом,
а не выражением.
Допускается ограниченная форма косвенности,
когда значение одного макроса является именем другого.
.Pp
В большинстве случаев
.Nm
не различает объектные макросы
(без аргументов) и функциональные макросы (с аргументами).
Вызов функционального макроса может появляться в
управляющих выражениях
.Ic #if
и
.Ic #elif .
Если макрос не определен явно,
или определен с помощью флага
.Fl D
в командной строке,
или с помощью
.Ic #define
в файле определений
.Fl f ,
его аргументы игнорируются.
Если макрос явно не определен в командной строке с помощью флага
.Fl U ,
или с помощью
.Ic #undef
в файле определений
.Fl f ,
он не должен иметь аргументов, так как это приводит к синтаксической ошибке.
.Pp
Утилита
.Nm
знает о C ровно столько,
чтобы понимать, когда одна из директив неактивна,
потому что находится внутри
комментария,
или не может быть вычислена, потому что разбита на строку с продолжением через обратную косую черту.
Она обнаруживает необычно отформатированные директивы препроцессора
и пропускает их без изменений, если форматирование слишком сложное для обработки.
(См. раздел
.Sx ИЗВЕСТНЫЕ ОШИБКИ
ниже.)
.Pp
Скрипт с именем
.Nm unifdefall
может быть использован для удаления всех условных директив
.Xr cpp 1
из файла.
Он использует
.Nm Fl s
и
.Nm cpp Fl dM
для получения списков всех управляющих макросов
и их определений (или их отсутствия),
затем вызывает
.Nm
с соответствующими аргументами для обработки файла.
.Sh ОПЦИИ
.Bl -tag -width indent -compact
.It Fl D Ns Ar символ Ns = Ns Ar значение
Указать, что макрос определен с заданным значением.
.Pp
.It Fl D Ns Ar символ
Указать, что макрос определен со значением 1.
.Pp
.It Fl U Ns Ar символ
Указать, что макрос не определен.
.Pp
Если один и тот же макрос появляется более чем в одном аргументе,
действует последнее вхождение.
.Pp
.It Fl iD Ns Ar символ Ns Op = Ns Ar значение
.It Fl iU Ns Ar символ
Строковые литералы C, комментарии
и продолжения строк
игнорируются внутри блоков
.Ic #ifdef
и
.Ic #ifndef ,
управляемых макросами,
заданными с помощью этих опций.
.Pp
.It Fl f Ar файл_определений
Файл
.Ar файл_определений
содержит директивы препроцессора
.Ic #define
и
.Ic #undef ,
которые имеют тот же эффект, что и соответствующие аргументы командной строки
.Fl D
и
.Fl U .
Вы можете использовать несколько аргументов
.Fl f
и смешивать их с аргументами
.Fl D
и
.Fl U ;
более поздние опции переопределяют более ранние.
.Pp
Каждая директива должна быть на одной строке.
Определения объектных макросов (без аргументов)
устанавливаются в заданное значение.
Определения функциональных макросов (с аргументами)
трактуются как установленные в 1.
.Pp
.Em Внимание:
строковые литералы и символьные константы не разбираются корректно в файлах
.Fl f .
.Pp
.It Fl b
Заменять удаленные строки пустыми строками
вместо их удаления.
Взаимоисключающая с опцией
.Fl B .
.Pp
.It Fl B
Сжимать пустые строки вокруг удаленного раздела.
Взаимоисключающая с опцией
.Fl b .
.Pp
.It Fl c
Инвертировать, т.е. строки, которые были бы удалены или заменены пустыми,
сохраняются, и наоборот.
.Pp
.It Fl d
Включить вывод отладочных сообщений.
.Pp
.It Fl e
По умолчанию
.Nm
сообщит об ошибке, если ей потребуется удалить
директиву препроцессора, занимающую более одной строки,
например, если у нее есть многострочный
комментарий, висящий в конце.
Флаг
.Fl e
заставляет ее игнорировать такую строку.
.Pp
.It Fl h
Вывести справку.
.Pp
.It Fl I Ns Ar путь
Указывает
.Nm unifdefall
дополнительное место для поиска файлов
.Ic #include .
Эта опция игнорируется утилитой
.Nm
для совместимости с
.Xr cpp 1
и упрощения реализации
.Nm unifdefall .
.Pp
.It Fl K
Всегда трактовать результат операторов
.Ic &&
и
.Ic ||
как неизвестный, если любой операнд неизвестен,
вместо использования сокращенного вычисления, когда неизвестные операнды не могут повлиять на результат.
Эта опция предназначена для совместимости с более старыми версиями
.Nm .
.Pp
.It Fl k
Обрабатывать строки
.Ic #if
и
.Ic #elif
с константными выражениями.
По умолчанию разделы, управляемые такими строками, пропускаются без изменений,
так как они обычно начинаются
и используются как своего рода комментарий для набросков будущей или прошлой разработки.
Было бы грубо удалять их, так же как и обычные комментарии.
.Pp
.It Fl m
Изменять один или несколько входных файлов на месте.
Если входной файл не изменен,
оригинал сохраняется вместо перезаписи идентичной копией.
.Pp
.It Fl M Ar расширение_резервной_копии
Изменять входные файлы на месте и сохранять резервные копии оригинальных файлов,
добавляя
.Ar расширение_резервной_копии
к именам входных файлов.
Расширение нулевой длины
.Ar расширение_резервной_копии
ведет себя так же, как опция
.Fl m .
.Pp
.It Fl n
Добавлять директивы
.Li #line
в вывод после любых удаленных строк,
чтобы ошибки, возникающие при компиляции выходного файла, соответствовали
номерам строк во входном файле.
.Pp
.It Fl o Ar выходной_файл
Записывать вывод в файл
.Ar выходной_файл
вместо стандартного вывода при обработке одного файла.
.Pp
.It Fl s
Вместо обычной обработки входного файла
эта опция заставляет
.Nm
выводить список макросов, используемых в
управляющих выражениях директив препроцессора.
.Pp
.It Fl S
Подобно опции
.Fl s , но также выводится глубина вложенности каждого макроса.
Это полезно для определения количества возможных комбинаций
взаимозависимых определенных/неопределенных макросов.
.Pp
.It Fl t
Отключает разбор строковых литералов C, комментариев
и продолжений строк,
что полезно
для простого текста.
Это общая версия флагов
.Fl iD
и
.Fl iU .
.Pp
.It Fl V
Вывести информацию о версии.
.Pp
.It Fl x Bro Ar 012 Brc
Установить режим статуса выхода в ноль, один или два.
Подробности см. в разделе
.Sx СТАТУС ВЫХОДА
ниже.
.El
.Pp
Утилита
.Nm
берет входные данные из
.Em stdin ,
если нет аргументов
.Ar файл .
Вы должны использовать опции
.Fl m
или
.Fl M ,
если есть несколько входных файлов.
Вы можете указать ввод из stdin или вывод в stdout с помощью
.Ql - .
.Pp
Утилита
.Nm
хорошо работает с опцией
.Fl D Ns Ar символ
утилиты
.Xr diff 1 .
.Sh СТАТУС ВЫХОДА
При обычном использовании статус выхода утилиты
.Nm
зависит от режима, установленного с помощью опции
.Fl x .
.Pp
Если режим выхода равен нулю (по умолчанию), то
.Nm
завершается со статусом 0, если вывод является точной копией ввода,
или со статусом 1, если вывод отличается.
.Pp
Если режим выхода равен единице,
.Nm
завершается со статусом 1, если вывод не изменен,
или 0, если он отличается.
.Pp
Если режим выхода равен двум,
.Nm
завершается со статусом ноль в обоих случаях.
.Pp
Во всех режимах выхода
.Nm
завершается со статусом 2 при возникновении ошибки.
.Pp
Статус выхода равен 0, если заданы опции командной строки
.Fl h
или
.Fl V .
.Sh ДИАГНОСТИКА
.Bl -item
.It
.Tn Конец файла
в комментарии
.It
Недопустимая директива
.Ic #elif ,
.Ic #else
или
.Ic #endif
.It
Отсутствует имя макроса в #define или #undef
.It
Запутанная строка управления препроцессора
.It
Преждевременный
.Tn конец файла
(с номером строки последней незавершенной директивы
.Ic #if )
.It
Слишком много уровней вложенности
.It
Неопознанная директива препроцессора
.It
Незавершенный символьный или строковый литерал
.El
.Sh СМ. ТАКЖЕ
.Xr cpp 1 ,
.Xr diff 1
.Pp
Домашняя страница unifdef находится по адресу
.Pa http://dotat.at/prog/unifdef
.Sh ИСТОРИЯ
Команда
.Nm
появилась в
.Bx 2.9 .
Поддержка
.Tn ANSI\~C
была добавлена в
.Fx 4.7 .
.Sh АВТОРЫ
.An -nosplit
Оригинальная реализация была написана
.An Dave Yost Aq Mt Dave@Yost.com .
.An Tony Finch Aq Mt dot@dotat.at
переписал ее для поддержки
.Tn ANSI\~C .
.Sh ИЗВЕСТНЫЕ ОШИБКИ
.Bl -bullet
.It
Вычисление выражений очень ограничено.
.It
Символьные константы не вычисляются.
Строковые литералы и символьные константы в файлах определений
.Fl f
игнорируются, а не разбираются как
часть токенов замены макроса.
.It
Распознается только базовая форма сырых строковых литералов C++,
как
без разделителей, как в
.It
Исходные файлы обрабатываются построчно,
поэтому директивы препроцессора, разбитые на более чем одну физическую строку
(из-за комментариев или обратной косой черты с новой строкой)
не могут быть обработаны в каждой ситуации.
.It
Триграфы не распознаются.
.It
Нет поддержки макросов с разными определениями в
разных точках исходного файла.
.It
Функциональность текстового режима и игнорирования не соответствует современному
поведению
.Xr cpp 1 .
.El
.Pp
Пожалуйста, отправляйте отчеты об ошибках по электронной почте на
.Aq Mt dot@dotat.at .
