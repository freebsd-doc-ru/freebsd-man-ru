.\"-
.\" Copyright (c) 1980, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)csh.1	8.1 (Berkeley) 6/8/93
.\"
.\" FRDP path ./share/doc/usd/04.csh/csh.1
.\" FRDP githash 97759ccc715c4b365432c16d763c50eecfcb1100
.\" FRDP hash256 623db0226e95314ec812a78ad861c83bad7dcf61b891c4b3d6ecb230f6850b6f
.EH 'USD:4-%''Введение в оболочку C shell'
.OH 'Введение в оболочку C shell''USD:4-%'
.TL
Введение в оболочку C shell
.AU
William Joy
(пересмотрено для 4.3BSD Mark Seiden)
.AI
Отделение компьютерных наук
.br
Факультет электротехники и компьютерных наук
.br
Калифорнийский университет, Беркли
.br
Беркли, Калифорния 94720
.AB
.I Csh
это новый интерпретатор командного языка для систем
.UX .
Он включает в себя хорошие возможности других оболочек и механизм
.I истории
подобный
.I redo
в \s-2INTERLISP\s0.
Хотя он включает многие возможности других оболочек, облегчающие
написание программ на языке оболочки (скриптов оболочки),
большинство уникальных возможностей
.I csh
предназначены скорее для интерактивного пользователя \s-2UNIX\s0.
.PP
Пользователи \s-2UNIX\s0, которые прочитали общее введение в систему,
найдут здесь ценное базовое объяснение оболочки.
Простое взаимодействие с терминалом через
.I csh
возможно после прочтения только первого раздела этого документа.
Второй раздел описывает возможности оболочки, которые вы можете
исследовать после того, как начнёте знакомиться с оболочкой.
Более поздние разделы представляют возможности, которые полезны, но не обязательны
для всех пользователей оболочки.
.PP
Дополнительная информация включает приложение, перечисляющее специальные символы оболочки,
и глоссарий терминов и команд, представленных в этом руководстве.
.AE
.SH
.if n .ND
Введение
.PP
.I Оболочка
это интерпретатор командного языка.
.I Csh
это название одного конкретного интерпретатора команд в
\s-2UNIX\s0.
Основная цель
.I csh
— преобразовывать строки команд, введённые в терминале, в
действия системы, такие как вызов других программ.
.I Csh
это пользовательская программа, такая же, какую вы могли бы написать.
Надеемся,
.I csh
станет очень полезной программой для вас
во взаимодействии с системой \s-2UNIX\s0.
.PP
В дополнение к этому документу вам захочется обратиться к копии
Справочного руководства пользователя \s-2UNIX\s0.
Документация по
.I csh
в разделе 1 руководства предоставляет полное описание всех
возможностей оболочки и является окончательным справочником по вопросам,
касающимся оболочки.
.PP
Многие слова в этом документе показаны
.I курсивом.
Это важные слова;
имена команд и слова, имеющие особое значение при обсуждении
оболочки и \s-2UNIX\s0.
Многие из слов определены в глоссарии в конце этого документа.
Если вы не знаете, что означает слово, вам следует
поискать его в глоссарии.
.SH
Благодарности
.PP
Множество людей предоставили хорошие отзывы о предыдущих версиях
.I csh
и помогли в отладке как оболочки, так и её документации.
Особенно я хотел бы поблагодарить Michael Ubell,
который сделал ключевое наблюдение, что команды истории могут быть
хорошо реализованы на основе структуры слов вводимого текста, и реализовал
прототип механизма истории в более старой версии оболочки.
Eric Allman также предоставил большое количество полезных комментариев по
оболочке, помогая унифицировать существующие концепции, а также выявить
и устранить бесполезные и малополезные возможности.
Mike O'Brien предложил механизм хэширования путей,
который ускоряет выполнение команд.
Jim Kulp добавил примитивы управления заданиями и стека каталогов и
добавил их документацию в это введение.
.br
.bp
.NH
Использование оболочки на терминале
.NH 2
Базовое понятие команд
.PP
.I Оболочка
в
\s-2UNIX\s0
действует в основном как средство, через которое вызываются другие
.I программы.
Хотя она имеет набор
.I встроенных
функций, которые выполняет непосредственно,
большинство команд вызывают выполнение программ, которые, по сути,
являются внешними по отношению к оболочке.
Таким образом, оболочка отличается от интерпретаторов команд других
систем как тем, что она является просто пользовательской программой, так и тем,
что используется почти исключительно как механизм для вызова других программ.
.PP
.I Команды
в системе \s-2UNIX\s0 состоят из списка строк или
.I слов,
интерпретируемых как
за которыми следуют
.I аргументы.
Таким образом, команда
.DS
mail bill
.DE
состоит из двух слов.
Первое слово
.I mail
называет команду, которую нужно выполнить, в данном случае
программу mail, которая отправляет сообщения другим пользователям.
Оболочка использует имя команды для её выполнения.
Она будет искать в ряде
.I каталогов
файл с именем
.I mail,
который, как ожидается, содержит программу mail.
.PP
Остальные слова команды передаются как
.I аргументы
самой команде при её выполнении.
В этом случае мы также указали аргумент
.I bill,
который интерпретируется программой
.I mail
как имя пользователя, которому нужно отправить почту.
В обычном использовании терминала мы могли бы использовать команду
.I mail
следующим образом.
.DS
% mail bill
У меня вопрос по документации csh.
В моём документе, кажется, отсутствует страница 5.
Существует ли страница пять?
	Bill
EOT
%
.DE
.PP
Здесь мы ввели сообщение для отправки
.I bill
и завершили его с помощью ^D, что послало конец файла
программе mail.
(Здесь и далее в этом документе обозначение ``^\fIx\fR''
следует читать как ``control-\fIx\fR'' и представляет нажатие клавиши \fIx\fR
при удерживании клавиши control.)
Программа mail
затем вывела символы `EOT' и передала наше сообщение.
Символы `% ' были напечатаны оболочкой до и после команды mail,
чтобы показать, что необходим ввод.
.PP
После вывода приглашения `% ' оболочка читала ввод команд с
нашего терминала.
Мы ввели полную команду `mail bill'.
Затем оболочка выполнила программу
.I mail
с аргументом
.I bill
и перешла в режим ожидания её завершения.
Программа mail затем читала ввод с нашего терминала, пока мы не подали сигнал
конца файла с помощью ^D, после чего оболочка заметила,
что mail завершилась,
и снова сообщила, что готова читать с терминала,
выведя другое приглашение `% '.
.PP
Это основная схема всего взаимодействия с \s-2UNIX\s0
через оболочку.
Полная команда вводится на терминале, оболочка выполняет
команду, и когда это выполнение завершается, она запрашивает новую команду.
Если вы запустите редактор на час, оболочка будет терпеливо ждать, пока
вы закончите редактирование, и послушно снова запросит вас, когда вы закончите.
.PP
Пример полезной команды, которую вы можете выполнить сейчас, — это команда
.I tset,
которая устанавливает символы по умолчанию
.I erase
и
.I kill
на вашем терминале — символ erase стирает последний
введённый символ, а символ kill стирает всю введённую вами строку.
По умолчанию символ erase — это клавиша delete (эквивалент `^?'),
а символ kill — `^U'. Некоторые предпочитают сделать символом erase
клавишу backspace (эквивалент `^H').
Вы можете сделать это, набрав
.DS
tset \-e
.DE
что говорит программе
.I tset
установить символ erase в значение по умолчанию для этого символа
(backspace).
.NH 2
Флаговые аргументы
.PP
Полезным понятием в \s-2UNIX\s0 является понятие
.I флагового
аргумента.
Хотя многие аргументы команд указывают имена файлов или имена пользователей,
некоторые аргументы скорее указывают дополнительную возможность команды,
которую вы хотите вызвать.
По соглашению такие аргументы начинаются с символа `\-' (дефис).
Таким образом, команда
.DS
ls
.DE
выведет список файлов в текущем
Опция
.I \-s
это опция размера, и
.DS
ls \-s
.DE
приводит к тому, что
.I ls
также выводит для каждого файла его размер в блоках по 512
символов.
Раздел руководства для каждой команды в справочном руководстве \s-2UNIX\s0
даёт доступные опции для каждой команды.
У команды
.I ls
имеется большое количество полезных и интересных опций.
У большинства других команд либо нет опций, либо есть одна-две опции.
Трудно запомнить опции команд, которые используются не очень
часто, поэтому большинство утилит \s-2UNIX\s0 выполняют только одну или две функции,
а не имеют большого количества трудно запоминаемых опций.
.NH 2
Вывод в файлы
.PP
Команды, которые обычно читают ввод или выводят вывод на терминал,
также могут быть выполнены с перенаправлением этого ввода и/или вывода в
файл.
.PP
Так, предположим, мы хотим сохранить текущую дату в файле с именем `now'.
Команда
.DS
date
.DE
выведет текущую дату на наш терминал.
Это происходит потому, что наш терминал является стандартным выводом по умолчанию
для команды date, и команда date печатает дату на свой
стандартный вывод.
Оболочка позволяет нам
.I перенаправить
стандартный вывод
команды с помощью
обозначения, использующего
.I метасимвол
`>' и имя файла, в который нужно поместить вывод.
Таким образом, команда
.DS
date > now
.DE
запускает команду
.I date
таким образом, что её стандартный вывод становится
файлом `now', а не терминалом.
Таким образом, эта команда помещает текущие дату и время в файл `now'.
Важно понимать, что команда
.I date
не знала, что её вывод идёт в файл, а не
на терминал.
Оболочка выполнила это
.I перенаправление
до начала выполнения команды.
.PP
Ещё один важный момент здесь заключается в том, что файл `now'
не обязательно должен существовать до выполнения команды
.I date;
оболочка создала бы файл, если бы он не существовал.
А если бы файл существовал?
Если бы он существовал ранее, его предыдущее содержимое было бы потеряно!
Существует опция оболочки
.I noclobber,
предотвращающая случайное перезаписывание;
она обсуждается в разделе 2.2.
.PP
Система обычно сохраняет файлы, которые вы создаёте с помощью `>', как и все другие файлы.
Таким образом, по умолчанию файлы являются постоянными. Если вы хотите создать файл,
который будет автоматически удалён, вы можете начать его имя с символа `#',
этот символ `scratch' обозначает, что файл будет
временным файлом.*
.FS
*Обратите внимание, что если ваш символ erase — это `#', вам придётся предварить `#' символом `\e'. Тот факт, что символ `#' является старым (до эры \s-2CRT\s0)
стандартным символом erase, означает, что он редко появляется в именах файлов, что
позволяет использовать это соглашение для временных файлов. Если вы используете
\s-2CRT\s0, ваш символ erase должен быть ^H, как мы показали
в разделе 1.1, как это можно настроить.
.FE
Система удалит такие файлы через пару дней,
или раньше, если место для файлов станет очень мало.
Таким образом, при выполнении команды
.I date
выше, нам на самом деле не нужно сохранять вывод навсегда, поэтому мы
скорее сделали бы
.DS
date > #now
.DE
.NH 2
Метасимволы в оболочке
.PP
Оболочка имеет большое количество
специальных символов (таких как `>'),
которые указывают специальные функции.
Мы говорим, что эти обозначения имеют
.I синтаксическое
и
.I семантическое
значение для оболочки.
В общем, большинство символов, не являющихся буквами или цифрами,
имеют специальное значение для оболочки.
Вскоре мы изучим средство
.I цитирования,
которое позволяет нам использовать
.I метасимволы
без особой обработки их оболочкой.
.PP
Метасимволы обычно оказывают эффект только тогда, когда оболочка читает
наш ввод.
Нам не нужно беспокоиться о размещении метасимволов оболочки в письме,
которое мы отправляем через
.I mail,
или когда мы вводим текст или данные в какую-либо другую программу.
Заметим, что оболочка читает ввод только тогда, когда она вывела приглашение
`% ' (хотя мы можем вводить наш ввод даже до того, как она запросит).
.NH 2
Ввод из файлов; конвейеры
.PP
Мы узнали выше, как
.I перенаправить
стандартный вывод
команды
в файл.
Также возможно перенаправить
стандартный ввод
команды из файла.
Это не часто необходимо, поскольку большинство команд читают из
файла, имя которого дано в качестве аргумента.
Мы можем дать команду
.DS
sort < data
.DE
чтобы запустить команду
.I sort
со стандартным вводом (откуда команда обычно
читает свой ввод) из файла
`data'.
Мы скорее сказали бы
.DS
sort data
.DE
позволяя команде
.I sort
самой открыть файл
`data'
для ввода, так как это требует меньше набора.
.PP
Мы должны отметить, что если бы мы просто набрали
.DS
sort
.DE
то программа sort сортировала бы строки со своего стандартного ввода.
Поскольку мы не
.I перенаправили
стандартный ввод, она бы сортировала строки по мере их ввода на терминале,
пока мы не наберём ^D для указания конца файла.
.PP
Очень полезной возможностью является способность объединять стандартный вывод
одной команды со стандартным вводом другой, т.е. запускать
команды в последовательности, известной как
.I конвейер.
Например, команда
.DS
ls \-s
.DE
обычно выводит список файлов в нашем каталоге с размером
каждого в блоках по 512 символов.
Если нас интересует, какой из наших файлов самый большой, мы
можем захотеть отсортировать его по размеру, а не по имени, что является
способом сортировки по умолчанию для
.I ls.
Мы могли бы посмотреть на множество опций
.I ls,
чтобы узнать, есть ли опция для этого, но в конечном итоге обнаружили бы,
что её нет.
Вместо этого мы можем использовать пару простых опций команды
.I sort,
объединив её с
.I ls,
чтобы получить то, что хотим.
.PP
Опция
.I \-n
у sort указывает числовую сортировку вместо алфавитной.
Таким образом,
.DS
ls \-s | sort \-n
.DE
указывает, что вывод команды
.I ls,
запущенной с опцией
.I \-s,
должен быть
.I перенаправлен
в команду
.I sort,
запущенную с опцией числовой сортировки.
Это дало бы нам отсортированный список наших файлов по размеру, но с
самыми маленькими сначала.
Затем мы могли бы использовать опцию
.I \-r
обратной сортировки и команду
.I head
в комбинации с предыдущей командой, выполнив
.DS
ls \-s | sort \-n \-r | head \-5
.DE
Здесь мы взяли список наших файлов, отсортированный по алфавиту,
каждый с указанием размера в блоках.
Мы перенаправили его на стандартный ввод команды
.I sort,
попросив её отсортировать численно в обратном порядке (самые большие сначала).
Затем этот вывод был передан команде
.I head,
которая выводит первые несколько строк.
В данном случае мы попросили
.I head
выдать первые 5 строк.
Таким образом, эта команда даёт нам имена и размеры наших 5 самых больших файлов.
.PP
Обозначение, введённое выше, называется механизмом
.I конвейера.
Команды, разделённые символами `\||\|', соединяются оболочкой вместе, и
стандартный вывод каждой передаётся на стандартный ввод следующей.
Самая левая команда в конвейере обычно будет брать свой стандартный
ввод с терминала, а самая правая будет помещать свой стандартный
вывод на терминал.
Другие примеры конвейеров будут приведены позже, когда мы обсудим
механизм истории;
одно важное использование конвейеров, которое будет там проиллюстрировано, — это
направление информации на построчный принтер.
.NH 2
Имена файлов
.PP
Многим выполняемым командам понадобятся имена файлов в качестве аргументов.
.I Пути
в \s-2UNIX\s0
состоят из некоторого количества
.I компонентов,
разделённых `/'.
Каждый компонент, кроме последнего, именует каталог, в котором находится следующий
компонент, фактически указывая
.I путь
по каталогам, который нужно пройти, чтобы достичь файла.
Таким образом, путь
.DS
/etc/motd
.DE
указывает файл в каталоге
`etc',
который является подкаталогом
.I корневого
каталога `/'.
Внутри этого каталога именуемый файл — `motd', что означает
`сообщение дня'.
.I Путь,
который начинается со слеша, называется
.I абсолютным
путём, поскольку он задан от абсолютной вершины всей
иерархии каталогов системы (
.I корня ).
.I Пути,
которые не начинаются с `/', интерпретируются как начинающиеся в текущем
рабочем каталоге, который по умолчанию является вашим
.I домашним
каталогом и может быть динамически изменён с помощью команды
.I cd
(сменить каталог).
Такие пути называются
.I относительными
относительно рабочего каталога, поскольку они находятся путём
старта в рабочем каталоге и спуска на более низкие уровни каталогов
для каждого
.I компонента
пути. Если путь не содержит слешей вообще, то
файл содержится в самом рабочем каталоге, и путь — это просто
имя файла в этом каталоге.
Абсолютные пути не имеют отношения
к рабочему каталогу.
.PP
Большинство имён файлов состоят из некоторого количества алфавитно-цифровых символов и
`.' (точек).
Фактически, все печатаемые символы, кроме `/' (слеша), могут появляться в именах файлов.
Неудобно иметь большинство неалфавитных символов в именах файлов,
поскольку многие из них имеют специальное значение для оболочки.
Символ `.' (точка) не является метасимволом оболочки и часто используется
для отделения
.I расширения
имени файла от основы имени.
Таким образом,
.DS
prog.c prog.o prog.errs prog.output
.DE
это четыре связанных файла.
Они имеют общую
.I основную
часть имени
(основная часть — это та часть имени, которая остаётся, когда отсекается завершающая
`.' и следующие за ней символы, которые не являются `.').
Файл
`prog.c'
может быть исходным кодом программы на C,
файл `prog.o' — соответствующим объектным файлом,
файл
`prog.errs' — ошибками, возникшими при компиляции программы,
а файл
`prog.output' — выводом запуска программы.
.PP
Если бы мы захотели обратиться ко всем четырём этим файлам в команде, мы могли бы
использовать обозначение
.DS
prog.*
.DE
Это выражение раскрывается оболочкой, до выполнения команды, которой оно является
аргументом, в список имён, начинающихся с `prog.'.
Символ `*' здесь сопоставляется с любой последовательностью (включая пустую)
символов в имени файла.
Сопоставленные имена сортируются по алфавиту и помещаются в
список аргументов
команды.
Таким образом, команда
.DS
echo prog.*
.DE
выведет имена
.DS
prog.c prog.errs prog.o prog.output
.DE
Заметим, что имена здесь в отсортированном порядке, и в другом
порядке, чем мы перечислили их выше.
Команда
.I echo
получает четыре слова в качестве аргументов, хотя мы набрали
только одно слово непосредственно как аргумент.
Четыре слова были сгенерированы
.I раскрытием
одного входного слова.
.PP
Также доступны другие обозначения для
.I раскрытия имён файлов.
Символ `?' сопоставляется с любым одиночным символом в имени файла.
Таким образом,
.DS
echo ? \|?? \|???
.DE
выведет строку имён файлов; сначала те, у которых имена из одного символа,
затем те, у которых имена из двух символов, и, наконец, те, у которых имена из трёх
символов.
Имена каждой длины сортируются независимо.
.PP
Другой механизм состоит из последовательности символов между `[' и `]'.
Эта метапоследовательность сопоставляется с любым одиночным символом из заключённого набора.
Таким образом,
.DS
prog.[co]
.DE
будет сопоставляться с
.DS
prog.c prog.o
.DE
в примере выше.
Мы также можем поместить два символа вокруг `\-' в этом обозначении, чтобы обозначить
диапазон.
Таким образом,
.DS
chap.[1\-5]
.DE
может сопоставляться с файлами
.DS
chap.1 chap.2 chap.3 chap.4 chap.5
.DE
если они существуют.
Это сокращённая запись для
.DS
chap.[12345]
.DE
и в остальном эквивалентна.
.PP
Важный момент: если список слов-аргументов для
команды (
.I аргументов
)
содержит синтаксис раскрытия имён файлов, и если этот синтаксис раскрытия имён файлов
не сопоставляется ни с одним существующим именем файла, то оболочка считает это
ошибкой и выводит диагностику
.DS
Нет совпадения.
.DE
и не выполняет команду.
.PP
Другой очень важный момент: файлы с символом `.' в
начале обрабатываются особым образом.
Ни `*', ни `?', ни механизм `[' `]' не будут сопоставляться с ним.
Это предотвращает случайное сопоставление с именами файлов `.' и `..'
в рабочем каталоге, которые имеют специальное значение для системы,
а также других файлов, таких как
.I \&.cshrc,
которые обычно не
видны.
Мы обсудим особую роль файла
.I \&.cshrc
позже.
.PP
Другой механизм раскрытия имён файлов даёт доступ к пути
.I домашнего
каталога других пользователей.
Это обозначение состоит из символа `~' (тильда), за которым следует имя входа другого пользователя.
Например, слово `~bill' будет преобразовано в путь `/usr/bill',
если домашний каталог для `bill' был `/usr/bill'.
Поскольку в больших системах каталоги входа пользователей могут быть разбросаны по
многим различным томам дисков с разными префиксами имён каталогов,
это обозначение предоставляет удобный способ доступа к файлам
других пользователей.
.PP
Особым случаем этого обозначения является просто `~', например `~/mbox'.
Это обозначение раскрывается оболочкой в файл `mbox' в вашем
.I домашнем
каталоге, т.е. в `/usr/bill/mbox' для меня на Ernie Co-vax, машине VAX
факультета компьютерных наук UCB, где этот документ был подготовлен.
Это может быть очень полезно, если вы использовали
.I cd
для смены на другой каталог и нашли файл, который хотите
скопировать с помощью
.I cp.
Если я дам команду
.DS
cp thatfile ~
.DE
оболочка раскроет эту команду в
.DS
cp thatfile /usr/bill
.DE
поскольку мой домашний каталог — /usr/bill.
.PP
Также существует механизм с использованием символов `{' и `}' для
сокращения набора слов, которые имеют общие части, но не могут
быть сокращены с помощью вышеуказанных механизмов, потому что они не являются файлами,
являются именами файлов, которые ещё не существуют,
или не могут быть так удобно описаны.
Этот механизм будет описан гораздо позже,
в разделе 4.2,
так как он используется реже.
.NH 2
Цитирование
.PP
Мы уже видели ряд метасимволов, используемых оболочкой.
Эти метасимволы создают проблему, поскольку мы не можем использовать их непосредственно
как части слов.
Так, команда
.DS
echo *
.DE
не выведет символ `*'.
Она либо выведет отсортированный список имён файлов в
текущем рабочем каталоге,
либо напечатает сообщение `Нет совпадения', если в
рабочем каталоге нет файлов.
.PP
Рекомендуемый механизм для помещения символов, не являющихся числами,
цифрами, `/', `.' или `\-', в слово-аргумент команды — это заключить
его в одиночные кавычки `\'', т.е.
.DS
echo \'*\'
.DE
Существует один специальный символ `!', который используется
механизмом
.I истории
оболочки и который не может быть
.I экранирован
помещением его внутри символов `\''.
Он и сам символ `\'' могут быть предварены одиночным `\e',
чтобы предотвратить их специальное значение.
Таким образом,
.DS
echo \e\'\e!
.DE
печатает
.DS
\'!
.DE
Этих двух механизмов достаточно, чтобы поместить любой печатаемый символ в слово,
которое является аргументом команды оболочки. Их можно комбинировать, как в
.DS
echo \e\'\'*\'
.DE
что печатает
.DS
\'*
.DE
поскольку первый `\e' экранировал первую `\'', а `*' был заключён
между символами `\''.
.NH 2
Завершение команд
.PP
Когда вы выполняете команду и оболочка
ожидает её завершения, есть несколько способов
заставить её остановиться.
Например, если вы наберёте команду
.DS
cat /etc/passwd
.DE
система выведет на ваш терминал копию списка всех пользователей системы.
Вероятно, это будет продолжаться несколько минут, если вы не остановите её.
Вы можете послать
.I сигнал
\s-2INTERRUPT\s0
команде
.I cat,
набрав ^C на вашем терминале.*
.FS
*На некоторых старых системах Unix клавиша \s-2DEL\s0 или \s-2RUBOUT\s0.
.FE
Поскольку
.I cat
не принимает мер предосторожности, чтобы избежать или обработать этот сигнал,
\s-2INTERRUPT\s0
приведёт к её завершению.
Оболочка заметит, что
.I cat
завершилась, и снова запросит вас приглашением `% '.
Если вы нажмёте \s-2INTERRUPT\s0 снова, оболочка просто
повторит своё приглашение, поскольку она обрабатывает сигналы \s-2INTERRUPT\s0
и выбирает продолжение выполнения команд, а не завершение,
как это сделала
.I cat,
что привело бы к выходу из системы.
.PP
Другой способ, которым многие программы завершаются, — это получение конца файла
со своего стандартного ввода.
Таким образом, программа
.I mail
в первом примере выше была завершена, когда мы набрали ^D,
что генерирует конец файла со стандартного ввода.
Оболочка также завершается, когда получает конец файла, печатая `logout';
\s-2UNIX\s0 затем выходит из системы.
Поскольку это означает, что набор слишком большого количества ^D может случайно вывести нас из системы,
в оболочке существует механизм для предотвращения этого.
Эта опция
.I ignoreeof
будет обсуждена в разделе 2.2.
.PP
Если команда имеет стандартный ввод, перенаправленный из файла, то она
обычно завершается, когда достигает конца этого файла.
Таким образом, если мы выполним
.DS
mail bill < prepared.text
.DE
команда mail завершится без необходимости набирать ^D.
Это происходит потому, что она прочитала до конца файла нашего файла
`prepared.text', в который мы поместили сообщение для `bill' с помощью программы редактирования.
Мы также могли бы сделать
.DS
cat prepared.text \||\| mail bill
.DE
поскольку команда
.I cat
затем записала бы текст через конвейер на стандартный ввод команды mail.
Когда команда
.I cat
завершилась бы, она бы закрыла
конвейер,
и команда
.I mail
получила бы конец файла от него и завершилась.
Использование конвейера здесь более сложно, чем перенаправление ввода,
поэтому мы скорее использовали бы первую форму.
Эти команды также можно было остановить, послав \s-2INTERRUPT\s0.
.PP
Ещё одна возможность остановить команду — временно приостановить её выполнение,
с возможностью продолжить выполнение позже. Это делается
посылкой сигнала \s-2STOP\s0 с помощью набора ^Z.
Этот сигнал заставляет все команды, выполняющиеся на терминале
(обычно одну, но больше, если выполняется конвейер), приостановиться.
Оболочка замечает, что команда(ы) были приостановлены, печатает
`Stopped' и затем запрашивает новую команду.
Ранее выполнявшаяся команда была приостановлена, но в остальном
не затронута сигналом \s-2STOP\s0. Любые другие команды могут быть выполнены
пока исходная команда остаётся приостановленной. Приостановленную команду можно
продолжить с помощью команды
.I fg
без аргументов. Оболочка затем повторно выведет команду,
чтобы напомнить вам, какая команда продолжается, и заставит команду
возобновить выполнение. Если какие-либо входные файлы, используемые приостановленной
командой, не были изменены за это время, приостановка не оказывает никакого
влияния на выполнение команды. Эта возможность может быть очень полезной
во время редактирования, когда нужно посмотреть на другой файл, прежде чем продолжить.
Пример приостановки команды следует.
.DS
% mail harold
Кто-то только что скопировал большой файл в мой каталог, и его имя
^Z
Stopped
% ls
funnyfile
prog.c
prog.o
% jobs
.ta 1.75i
[1]  + Stopped	mail harold
% fg
mail harold
funnyfile. Вы знаете, кто это сделал?
EOT
%
.so tabs
.DE
В этом примере кто-то отправлял сообщение Harold и забыл
имя файла, который хотел упомянуть. Команда mail была приостановлена
набором ^Z. Когда оболочка заметила, что программа mail
приостановлена, она напечатала `Stopped' и запросила новую команду. Затем была
набрана команда
.I ls,
чтобы узнать имя файла. Была запущена команда
.I jobs,
чтобы узнать, какая команда приостановлена.
В это время была набрана команда
.I fg,
чтобы продолжить выполнение программы mail. Ввод
в программу mail был затем продолжен и закончен с помощью ^D,
который указал конец сообщения, после чего программа mail
напечатала EOT. Команда
.I jobs
покажет, какие команды приостановлены.
^Z следует набирать только в начале строки, поскольку
всё, набранное на текущей строке, отбрасывается, когда сигнал посылается
с клавиатуры. Это также происходит с сигналами \s-2INTERRUPT\s0 и \s-2QUIT\s0.
Больше информации о
приостановке заданий и управлении ими даётся в
разделе 2.6.
.PP
Если вы пишете или запускаете программы, которые не полностью отлажены, то может
понадобиться остановить их несколько неаккуратно.
Это можно сделать, послав им сигнал \s-2QUIT\s0,
посылаемый набором ^\e.
Это обычно заставляет оболочку выдать сообщение типа:
.DS
Quit (Core dumped)
.DE
указывающее, что файл
`core' был создан, содержащий информацию о состоянии работающей программы
в момент её завершения из-за сигнала \s-2QUIT\s0.
Вы можете изучить этот файл сами или передать информацию
поддерживающему программу лицу, указав, где находится
файл core.
.PP
Если вы запускаете фоновые команды (как объяснено в разделе 2.6), то эти
команды будут игнорировать сигналы \s-2INTERRUPT\s0 и \s-2QUIT\s0 на
терминале. Чтобы остановить их, вы должны использовать команду
.I kill.
См. раздел 2.6 для примера.
.PP
Если вы хотите изучить вывод команды, не позволяя ему уходить
с экрана, как это делает вывод команды
.DS
cat /etc/passwd
.DE
можно использовать команду
.DS
more /etc/passwd
.DE
Программа
.I more
делает паузу после каждого полного экрана и печатает `\-\-More\-\-',
после чего вы можете нажать пробел для получения ещё одного экрана, Enter
для получения ещё одной строки, `?' для получения справки по другим командам или `q' для завершения
программы
.I more.
Вы также можете использовать more как фильтр, т.е.
.DS
cat /etc/passwd | more
.DE
работает так же, как более простая команда more выше.
.PP
Для остановки вывода команд, не связанных с
.I more,
можно использовать
клавишу ^S для остановки печати. Печать возобновится, когда вы
нажмёте ^Q или любую другую клавишу, но ^Q обычно используется, потому что
он только возобновляет вывод и не становится вводом для программы,
которая выполняется. Это хорошо работает на низкоскоростных терминалах, но на скорости 9600
бод трудно нажимать ^S и ^Q достаточно быстро, чтобы разбивать
вывод по страницам красиво, и обычно используется программа типа
.I more.
.PP
Дополнительная возможность — использовать символ ^O flush output;
когда этот символ набран, весь вывод от текущей команды выбрасывается (быстро)
до следующего чтения ввода или до следующего приглашения оболочки. Это можно использовать, чтобы позволить команде
завершиться без необходимости терпеть вывод на медленном
терминале; ^O является переключателем, поэтому сброс можно выключить,
снова набрав ^O, пока вывод сбрасывается.
.NH 2
Что теперь?
.PP
Мы пока увидели ряд механизмов оболочки и узнали много
о том, как она работает.
Оставшиеся разделы пойдут ещё дальше во внутренности
оболочки, но вам наверняка захочется попробовать использовать
оболочку, прежде чем вы продвинетесь дальше.
Чтобы попробовать её, вы можете войти в \s-2UNIX\s0 и набрать следующую
команду системе:
.DS
chsh myname /bin/csh
.DE
Здесь `myname' должно быть заменено именем, которое вы ввели в ответ на
приглашение системы `login:' для входа в систему.
Таким образом, я бы использовал `chsh bill /bin/csh'.
.B
Это нужно сделать только один раз; это вступит в силу при следующем входе.
.R
Теперь вы готовы попробовать использовать
.I csh.
.PP
До выполнения команды `chsh' оболочка, которую вы используете при
входе в систему, — `/bin/sh'.
Фактически, большая часть вышесказанного применима к `/bin/sh'.
Следующий раздел представит многие особенности, свойственные именно
.I csh,
поэтому вам следует сменить вашу оболочку на
.I csh
до того, как вы начнёте читать его.
.bp
